/** * sekati.collisions.AbstractCollisionDetector * @version 1.0.0 * @author jason m horwitz | sekati.com * Copyright (C) 2009  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php *  * Based on the CDK work of coreyoneil. */package sekati.collisions {	import sekati.collisions.CollisionAngle;	import sekati.collections.TypedArray;	import sekati.display.Canvas;	import sekati.events.CollisionEvent;	import sekati.events.FramePulse;	import sekati.log.Logger;	import sekati.math.MathBase;	import sekati.utils.TypeEnforcer;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.errors.EOFError;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.geom.ColorTransform;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.text.TextFormat;	import flash.utils.ByteArray;			/**	 * AbstractCollisionDetector provides the core collision detection logic abstract to its subclasses.	 *  	 * <p><code>BitmapData</code> generated from the display objects ared used in the detection of 	 * collisions & the collision angle which is calculated based on the display objects' shape 	 * where the collision occurs.</p>	 * 	 * @see sekati.collisions.Collision	 * @see sekati.collisions.CollisionAngle	 * @see sekati.collisions.CollisionDetector	 * @see sekati.collisions.GroupCollisionDetector	 * @see sekati.events.CollisionEvent	 */	public class AbstractCollisionDetector extends EventDispatcher {		protected var objectArray : TypedArray;		protected var objectCheckArray : TypedArray;		protected var objectCollisionArray : TypedArray;		private var colorExclusionArray : Array;		private var bmd1 : BitmapData;		private var bmd2 : BitmapData;		private var bmdResample : BitmapData;		private var pixels1 : ByteArray;		private var pixels2 : ByteArray;		private var rect1 : Rectangle;		private var rect2 : Rectangle;		private var transMatrix1 : Matrix;		private var transMatrix2 : Matrix;		private var colorTransform1 : ColorTransform;		private var colorTransform2 : ColorTransform;		private var item1Registration : Point;		private var item2Registration : Point;		private var _alphaThreshold : Number;		private var _returnAngleType : String;		private var _isMonitoring : Boolean;		/**		 * AbstractCollisionDetector Constructor		 */		public function AbstractCollisionDetector() {			TypeEnforcer.enforceAbstract( this, AbstractCollisionDetector );				init( );		}		/*** @private */		private function init() : void {						objectArray = new TypedArray( DisplayObject );			objectCheckArray = new TypedArray( Array );			objectCollisionArray = new TypedArray( Collision );			colorExclusionArray = new Array( );				_alphaThreshold = 0;			_returnAngleType = CollisionAngle.NONE;		}		/**		 * Start frame-based automatic collision monitoring.		 */		public function startMonitor() : void {			if(!_isMonitoring) {				_isMonitoring = true;				FramePulse.$.addFrameListener( monitor );			}		}		/**		 * Stop frame-based automatic collision monitoring.		 */		public function stopMonitor() : void {			if(_isMonitoring) {				_isMonitoring = false;				FramePulse.$.removeFrameListener( monitor );			}		}		/**		 * Add a <code>DisplayObject</code> to the list of objects to check for collisions. 		 */		public function addItem(obj : DisplayObject) : void {			if(!obj.stage) {				Logger.$.warn( this, obj + " must be added to the display list for proper collision detection." );			}			objectArray.push( obj );		}		/**		 * Remove a <code>DisplayObject</code> from the list of objects to check for collisions.		 */		public function removeItem(obj : DisplayObject) : void {			var isFound : Boolean;			var len : int = objectArray.length;			for(var i : uint = 0; i < len ; i++) {				if(objectArray[i] == obj) {					objectArray.splice( i, 1 );					isFound = true;					break;				}			}			if(!isFound) {				Logger.$.warn( this, obj + " could not be removed: not be found in item list." );			}		}		/**		 * Defines a color or color range to exclude from collision detections. <i>The excludeColor() method expects a 32 bit color value</i>. 		 * Optional ranges based on this color can be specified for all channels using the additional parameters. Each range accepts 		 * integral values from 0 to 255, accounting for all values for each color channel. The ranges move in both directions at the 		 * amount specified for each channel.		 * @param color32 	 	The color to exclude. Must be a 32 bit value (E.g. <code>0xFFFFFFFF</code>).		 * @param alphaRange 	The integral range of alpha values to exclude, based on the color's alpha value. Valid values are 0 - 255.		 * @param redRange 		The integral range of red values to exclude, based on the color's red value. Valid values are 0 - 255		 * @param greenRange 	The integral range of green values to exclude, based on the color's green value. Valid values are 0 - 255		 * @param blueRange 	The integral range of blue values to exclude, based on the color's blue value. Valid values are 0 - 255		 * @see #removeExcludeColor		 */		public function excludeColor(color32 : uint, alphaRange : uint = 255, redRange : uint = 20, greenRange : uint = 20, blueRange : uint = 20) : void {			var colorExclusion : Object = { color:color32, alpha:alphaRange, red:redRange, green:greenRange, blue:blueRange };			colorExclusionArray.push( colorExclusion );		}		/**		 * Removes the color specified from the list of colors to exclude from collision detections. Must be a color previously added 		 * using the <code>excludeColor()</code> method. Expects a 32 bit color value. 		 * @param color32 	 	The color to exclude. Must be a 32 bit value (E.g. <code>0xFFFFFFFF</code>).		 * @see #excludeColor		 */		public function removeExcludeColor(color32 : uint) : void {			var isFound : Boolean;			var numColors : int = colorExclusionArray.length;			for(var i : uint = 0; i < numColors ; i++) {				if(colorExclusionArray[i].color == color32) {					colorExclusionArray.splice( i, 1 );					isFound = true;					break;				}			}						if(!isFound) {				Logger.$.warn( this, "Color could not be removed - color not found in exclusion list [" + color32 + "]" );			}		}		/**		 * Stub function for subclasses which checks for collisions and returns a <code>Collision TypedArray</code> 		 * containing all <code>Collision</code>'s.		 */		public function checkCollisions() : TypedArray {			return objectCollisionArray;		}			/**		 * Clear the <code>objectCheckArray</code> and <code>objectCollisionArray</code>.		 */		protected function clearArrays() : void {			while(objectCheckArray.length) {				objectCheckArray.pop( );			}			while(objectCollisionArray.length) {				objectCollisionArray.pop( );			}		}		/**		 * Frame-based collision monitoring dispatches <code>CollisionEvent</code>'s 		 * when one or more collisions are detected. 		 * 		 * <p>You must explicitly call <code>startMonitor()</code> or <code>stopMonitor()</code> to		 * begin/end monitoring. The status may be checked via <code>isMonitoring</code></p>		 */		protected function monitor(e : Event) : void {			checkCollisions( );			if(objectCollisionArray.length > 0) {				dispatchEvent( new CollisionEvent( CollisionEvent.COLLISION, objectCollisionArray ) );			}					}		/*** @private */		protected function findCollisions(item1 : *, item2 : *) : void {			var item1_isText : Boolean = false;			var item2_isText : Boolean = false;			try {				var tf : TextFormat = item1.getTextFormat( );				item1_isText = (item1.antiAliasType == "advanced") ? true : false;				item1.antiAliasType = (item1.antiAliasType == "advanced") ? "normal" : item1.antiAliasType;			}			catch(e : Error) {			}						try {				tf = item2.getTextFormat( );				item2_isText = (item1.antiAliasType == "advanced") ? true : false;				item2.antiAliasType = (item2.antiAliasType == "advanced") ? "normal" : item2.antiAliasType;			}			catch(e : Error) {			}						colorTransform1 = item1.transform.colorTransform;			colorTransform2 = item2.transform.colorTransform;						item1Registration = new Point( item1.x, item1.y );			item2Registration = new Point( item2.x, item2.y );			item1Registration = item1.parent.localToGlobal( item1Registration );			item2Registration = item2.parent.localToGlobal( item2Registration );						if((item2.width * item2.height) > (item1.width * item1.height)) {				bmd1 = new BitmapData( item1.width, item1.height, true, 0x00FFFFFF );  				bmd2 = new BitmapData( item1.width, item1.height, true, 0x00FFFFFF );								rect1 = item1.getBounds( Canvas.stage );								transMatrix1 = item1.transform.matrix;				transMatrix1.tx = (item1Registration.x - rect1.left);				transMatrix1.ty = (item1Registration.y - rect1.top);								transMatrix2 = item2.transform.matrix;				transMatrix2.tx = (item2Registration.x - rect1.left);				transMatrix2.ty = (item2Registration.y - rect1.top);			} else {				bmd1 = new BitmapData( item2.width, item2.height, true, 0x00FFFFFF );  				bmd2 = new BitmapData( item2.width, item2.height, true, 0x00FFFFFF );								rect2 = item2.getBounds( Canvas.stage );							transMatrix1 = item1.transform.matrix;				transMatrix1.tx = (item1Registration.x - rect2.left);				transMatrix1.ty = (item1Registration.y - rect2.top);								transMatrix2 = item2.transform.matrix;				transMatrix2.tx = (item2Registration.x - rect2.left);				transMatrix2.ty = (item2Registration.y - rect2.top);			}						bmd1.draw( item1, transMatrix1, colorTransform1, null, null, true );			bmd2.draw( item2, transMatrix2, colorTransform2, null, null, true );						pixels1 = bmd1.getPixels( new Rectangle( 0, 0, bmd1.width, bmd1.height ) );			pixels2 = bmd2.getPixels( new Rectangle( 0, 0, bmd1.width, bmd1.height ) );							var k : uint = 0;			var value1 : uint = 0;			var value2 : uint = 0;			var collisionPoint : Number = -1;			var overlap : uint = 0;			pixels1.position = 0;			pixels2.position = 0;						while(k < pixels1.length) {				k = pixels1.position;								try {					value1 = pixels1.readUnsignedInt( );					value2 = pixels2.readUnsignedInt( );				}				catch(e : EOFError) {					break;				}								var alpha1 : uint = value1 >> 24 & 0xFF;				var alpha2 : uint = value2 >> 24 & 0xFF;								if(alpha1 >= _alphaThreshold && alpha2 >= _alphaThreshold) {						var colorFlag : Boolean = false;					if(colorExclusionArray.length) {						var red1 : uint = value1 >> 16 & 0xFF;						var red2 : uint = value2 >> 16 & 0xFF;						var green1 : uint = value1 >> 8 & 0xFF;						var green2 : uint = value2 >> 8 & 0xFF;						var blue1 : uint = value1 & 0xFF;						var blue2 : uint = value2 & 0xFF;												var a : uint;						var r : uint;						var g : uint;						var b : uint;						var item1Flags : uint;						var item2Flags : uint;												for(var n : uint = 0; n < colorExclusionArray.length ; n++) {							a = colorExclusionArray[n].color >> 24 & 0xFF;							r = colorExclusionArray[n].color >> 16 & 0xFF;							g = colorExclusionArray[n].color >> 8 & 0xFF;							b = colorExclusionArray[n].color & 0xFF;														item1Flags = 0;							item2Flags = 0;							if((blue1 >= b - colorExclusionArray[n].blue) && (blue1 <= b + colorExclusionArray[n].blue)) {								item1Flags++;							}							if((blue2 >= b - colorExclusionArray[n].blue) && (blue2 <= b + colorExclusionArray[n].blue)) {								item2Flags++;							}							if((green1 >= g - colorExclusionArray[n].green) && (green1 <= g + colorExclusionArray[n].green)) {								item1Flags++;							}							if((green2 >= g - colorExclusionArray[n].green) && (green2 <= g + colorExclusionArray[n].green)) {								item2Flags++;							}							if((red1 >= r - colorExclusionArray[n].red) && (red1 <= r + colorExclusionArray[n].red)) {								item1Flags++;							}							if((red2 >= r - colorExclusionArray[n].red) && (red2 <= r + colorExclusionArray[n].red)) {								item2Flags++;							}							if((alpha1 >= a - colorExclusionArray[n].alpha) && (alpha1 <= a + colorExclusionArray[n].alpha)) {								item1Flags++;							}							if((alpha2 >= a - colorExclusionArray[n].alpha) && (alpha2 <= a + colorExclusionArray[n].alpha)) {								item2Flags++;							}														if((item1Flags == 4) || (item2Flags == 4)) {								colorFlag = true;							}						}					}										if((collisionPoint == -1) && (!colorFlag)) {						if(_returnAngleType != CollisionAngle.NONE) {							collisionPoint = k / 4;							var angle : Number = findAngle( item1, item2, collisionPoint );						} else {							angle = -1;							collisionPoint = 0;						}					}										overlap = (!colorFlag) ? overlap + 1 : overlap;				}			}						if(overlap) {				var recordedCollision : Collision;				if((item2.width * item2.height) < (item1.width * item1.height)) {					//var recordedCollision : Object = { object1:item2, object2:item1, angle:angle, overlap:overlap };					recordedCollision = new Collision( item2, item1, angle, overlap ); 					objectCollisionArray.push( recordedCollision );				} else {					//recordedCollision = { object1:item1, object2:item2, angle:angle, overlap:overlap };					recordedCollision = new Collision( item1, item2, angle, overlap );					objectCollisionArray.push( recordedCollision );				}			}						if(item1_isText) {				item1.antiAliasType = "advanced";			}			if(item2_isText) {				item2.antiAliasType = "advanced";			}						item1_isText = item2_isText = false;		}		/*** @private */		private function findAngle(item1 : DisplayObject, item2 : DisplayObject, collisionPoint : Number) : Number {			if((item2.width * item2.height) > (item1.width * item1.height)) {				var rowWidth : uint = Math.round( item1.width );				var columnHeight : uint = Math.round( item1.height );				var center : Point = new Point( (item1.width >> 1), (item1.height >> 1) );				var pixels : ByteArray = pixels2;			} else {				rowWidth = Math.round( item2.width );				columnHeight = Math.round( item2.height );				center = new Point( (item2.width >> 1), (item2.height >> 1) );				pixels = pixels1;			}			var collisionY : Number = collisionPoint / rowWidth;			var collisionX : Number = collisionPoint % rowWidth;						collisionX = (collisionX != 0) ? (collisionX >> 5) * rowWidth : 0;			if((collisionX == 0) && (collisionY == 0)) {				collisionX = collisionY = 1;			}						if((item2.width * item2.height) > (item1.width * item1.height)) {				transMatrix2.tx += (center.x);				transMatrix2.ty += (center.y);				bmdResample = new BitmapData( item1.width * 2, item1.height * 2, true, 0x00FFFFFF );				bmdResample.draw( item2, transMatrix2, colorTransform2, null, null, true );				pixels = bmdResample.getPixels( new Rectangle( 0, 0, bmdResample.width, bmdResample.height ) );			} else {				transMatrix1.tx += center.x;				transMatrix1.ty += center.y;				bmdResample = new BitmapData( item2.width * 2, item2.height * 2, true, 0x00FFFFFF );				bmdResample.draw( item1, transMatrix1, colorTransform1, null, null, true );				pixels = bmdResample.getPixels( new Rectangle( 0, 0, bmdResample.width, bmdResample.height ) );			}			center.x = (bmdResample.width >> 1);			center.y = (bmdResample.height >> 1);						columnHeight = Math.round( bmdResample.height );			rowWidth = Math.round( bmdResample.width );						var pixel : uint, thisAlpha : uint, lastAlpha : int, edgeArray : Array = new Array( );			for(var j : uint = 0; j < columnHeight ; j++) {				var k : uint = j * 4 * rowWidth;				pixels.position = k;				lastAlpha = -1;				while(k < ((j + 1) * rowWidth * 4)) {					k = pixels.position;										try {						pixel = pixels.readUnsignedInt( );					}					catch(e : EOFError) {						break;					}															thisAlpha = pixel >> 24 & 0xFF;										if(lastAlpha == -1) {						lastAlpha = thisAlpha;					} else {						if(thisAlpha >= _alphaThreshold) {							var colorFlag : Boolean = false;							if(colorExclusionArray.length) {								var red1 : uint = pixel >> 16 & 0xFF, green1 : uint = pixel >> 8 & 0xFF, blue1 : uint = pixel & 0xFF;																var a : uint, r : uint, g : uint, b : uint, item1Flags : uint;																var numColors : uint = colorExclusionArray.length;								for(var n : uint = 0; n < numColors ; n++) {									a = colorExclusionArray[n].color >> 24 & 0xFF;									r = colorExclusionArray[n].color >> 16 & 0xFF;									g = colorExclusionArray[n].color >> 8 & 0xFF;									b = colorExclusionArray[n].color & 0xFF;																		item1Flags = 0;									if((blue1 >= b - colorExclusionArray[n].blue) && (blue1 <= b + colorExclusionArray[n].blue)) {										item1Flags++;									}									if((green1 >= g - colorExclusionArray[n].green) && (green1 <= g + colorExclusionArray[n].green)) {										item1Flags++;									}									if((red1 >= r - colorExclusionArray[n].red) && (red1 <= r + colorExclusionArray[n].red)) {										item1Flags++;									}									if((thisAlpha >= a - colorExclusionArray[n].alpha) && (thisAlpha <= a + colorExclusionArray[n].alpha)) {										item1Flags++;									}																		if(item1Flags == 4) {										colorFlag = true;									}								}							}														if(!colorFlag) {								edgeArray.push( k / 4 );							}						}					}				}			}						var edgePoint : uint;			var edgeY : uint;			var edgeX : uint;			var slope : Point;			var slopeArray : Array = new Array( );			var numEdges : int = edgeArray.length;			for(j = 0; j < numEdges ; j++) {				edgePoint = edgeArray[j];				edgeY = edgePoint / rowWidth;				edgeX = edgePoint % rowWidth;								edgeX = edgeX != 0 ? (edgeX / bmdResample.width) * rowWidth : 0;				slope = new Point( (edgeX - center.x), (center.y - edgeY) );								slopeArray.push( slope );			}			var slopeYAvg : Number = 0, slopeXAvg : Number = 0, numSlopes : int = slopeArray.length;			for(j = 0; j < numSlopes ; j++) {				slopeYAvg += slopeArray[j].y;				slopeXAvg += slopeArray[j].x;			}						var average : Number = returnDegrees( Math.atan2( slopeYAvg, slopeXAvg ) );			average = ~average + 1;			average = (_returnAngleType == CollisionAngle.RADIAN) ? returnRadians( average ) : average;			return average;		}		/*** @private */		private function returnDegrees(rads : Number) : Number {			var degs : Number = rads * 180 / Math.PI;			return degs;		}		/*** @private */		private function returnRadians(degs : Number) : Number {			var rads : Number = degs * Math.PI / 180;			return rads;		}		/**		 * A floating point value from <code>0 - 1</code> that determines the minimum alpha value to check for collisions. 		 */		public function get alphaThreshold() : Number {			return _alphaThreshold;		}				/*** @private */		public function set alphaThreshold(a : Number) : void {			a = MathBase.clamp( a, 0, 1 );			_alphaThreshold = a * 255;		}		/**		 * Determines if the angle returned from a collision is in <code>CollisionAngle.RADIAN</code> or 		 * <code>CollisionAngle.DEGREE_ANGLE_TYPE</code> (Default: <code>CollisionAngle.NONE</code>). 		 */		public function get returnAngleType() : String {			return _returnAngleType;		}		/*** @private */		public function set returnAngleType(returnType : String) : void {			if( returnType != CollisionAngle.RADIAN && returnType != CollisionAngle.DEGREE) {				Logger.$.error( this, "returnAngleType expects CollisionAngle.RADIAN or CollisionAngle.DEGREE." );				return;			}			_returnAngleType = returnType;		}		/**		 * The number of <code>DisplayObject</code>s being checked for collision. 		 */		public function get numChildren() : uint {			return objectArray.length;		}		/**		 * Whether the frame-base collision monitor is running.		 */		public function get isMonitoring() : Boolean {			return _isMonitoring;		}			}}