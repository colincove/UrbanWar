/** * sekati.collisions.CollisionDetector * @version 1.0.0 * @author jason m horwitz | sekati.com * Copyright (C) 2009  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php *  * Based on the CDK work of coreyoneil. */package sekati.collisions {	import sekati.collections.TypedArray;	import sekati.collisions.AbstractCollisionDetector;	import sekati.log.Logger;		import flash.display.DisplayObject;			/**	 * CollisionDetector provides collision detection to <i>a single target display 	 * object</i> against all other display objects registered with the detector (<b>one to many</b>).	 * 	 * @example <listing version="3.0">	 * var detector : CollisionDetector = new CollisionDetector( target, A, B, C );	 * </listing>	 * Would detect:<ul>	 * <li><code>A</code> colliding with <code>target</code></li>	 * <li><code>B</code> colliding with <code>target</code></li>	 * <li><code>C</code> colliding with <code>target</code></li>	 * </ul>	 * ... however the it <i>would not</i> detect <code>A</code> colliding with </code>B</code>.	 * 	 * <p>You may apply an <code>alphaThreshold</code> to prevent collisions on perimeter alphas, prevent certain colors	 * from registering collisions with <code>excludeColor()</code> or aquire the angle of the collision by setting the 	 * <code>returnAngleType</code> to one of the provided <code>CollisionAngle</code>'s.</p>	 * 	 * @example <listing version="3.0">	 * detector.alphaThreshold = 0.5; 						// areas with an alpha >= 0.5 will create a collision.	 * detector.excludeColor( 0xffff0000 ); 				// The 32-bit color to exclude from collisions.	 * detector.returnAngleType = CollisionAngle.RADIAN; 	// would return the collision angle as radian in the Collision instance	 * </listing>	 * 	 * <p>You may choose to use the built-in frame-based monitoring function to check & respond to <code>Collision</code>'s:</p>	 * 	 * @example <listing version="3.0">	 * private function collisionHandler( e : CollisionEvent ) : void {	 * 		var list = e.collisions; // a TypedArray containing one or more Collision instances.	 * 		for ( var i : int = 0; i < list.length; i++) {	 * 			var collision : Collision = list[i] as Collision;	 * 			trace("Collision detected: " + collision.object1 + " & " + collision.object2 + " (angle: " + collision.angle + ", overlap: " + collision.overlap + ")");	 * 		}	 * }	 * detector.addEventListener( CollisionEvent.COLLISION, collisionHandler );	 * detector.startMonitor();	 * </listing>	 * 	 * @see sekati.collisions.Collision	 * @see sekati.collisions.CollisionAngle	 * @see sekati.collisions.AbstractCollisionDetector	 * @see sekati.collisions.CollisionDetector	 * @see sekati.collisions.GroupCollisionDetector	 * @see sekati.events.CollisionEvent	 */	public class CollisionDetector extends AbstractCollisionDetector {		/**		 * CollisionDetector Constructor		 * @param target 	object to detect collisions upon.		 * @param objs 		which the <code>target</code> may collide with.		 */		public function CollisionDetector(target : DisplayObject, ... objs : Array) {			super( );			addItem( target );			for(var i : uint = 0; i < objs.length ; i++) {				addItem( objs[i] );			}		}		/**		 * Check for collisions with the <code>target</code>, if an object collided it is recorded and returned by 		 * <code>checkCollisions()</code> as an TypedArray of <code>Collision</code> objects.		 */		override public function checkCollisions() : TypedArray {			clearArrays( );						var len : uint = objectArray.length;						if (len < 2) {				//Logger.$.warn( this, "There must be at least one object added other than the target for collision detection." );				return objectCollisionArray;			}						var item1 : * = objectArray[0];			for(var i : uint = 1; i < len ; i++) {				var item2 : * = objectArray[i];					if(item1.hitTestObject( item2 )) {					objectCheckArray.push( [ item1,item2 ] );				}			}						if(objectCheckArray.length) {				len = objectCheckArray.length;				for(i = 0; i < len ; i++) {					findCollisions( objectCheckArray[i][0], objectCheckArray[i][1] );				}			}			return objectCollisionArray;		}		/**		 * Replaces the <code>target DisplayObject</code> with the <code>DisplayObject</code> specified. 		 */		public function swapTarget(target : DisplayObject) : void {			if(!target.root) {				Logger.$.warn( this, "Items added for collision detection must be on the display list." );			}			objectArray[0] = target;		}		/**		 * @inheritDoc		 */		override public function removeItem(obj : DisplayObject) : void {			var isFound : Boolean = false;			var len : int = objectArray.length;			for(var i : uint = 0; i < len ; i++) {				if(objectArray[i] == obj) {					if(i == 0) {						throw new Error( "You cannot remove the target from the collision list. Use swapTarget to change the target instead." );					} else {						objectArray.splice( i, 1 );						isFound = true;						break;					}				}			}				if(!isFound) {				throw new Error( obj + " could not be removed - object not found in item list." );			}		}			}}