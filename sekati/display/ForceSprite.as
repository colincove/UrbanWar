/** * sekati.display.ForceSprite * @version 1.0.2 * @author jason m horwitz | sekati.com * Copyright (C) 2009  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.display {	import sekati.display.InteractiveSprite;	import sekati.events.FramePulse;	import sekati.math.MathBase;		import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Rectangle;			/**	 * ForceSprite provides an <code>InteractiveSprite</code> which have quasi-physics forces applied to it.	 */	public class ForceSprite extends InteractiveSprite {				/*** @private */		protected var _boundRect : Rectangle;				// velocity		/*** @private */		protected var _vx : Number;		/*** @private */		protected var _vy : Number;				// acceleration (user defined)		/*** @private */		protected var _ax : Number;		/*** @private */		protected var _ay : Number;				// current		/*** @private */		protected var _cx : Number;		/*** @private */		protected var _cy : Number;		// drag		/*** @private */		protected var _dx : Number;		/*** @private */		protected var _dy : Number;						/*** @private */		protected var _friction : Number;		/*** @private */		protected var _gravityY : Number;		/*** @private */		protected var _gravityX : Number;		/*** @private */		protected var _mass : Number;		/*** @private */		protected var _isDrag : Boolean;		/*** @private */		protected var _isDraggable : Boolean;		/*** @private */		protected var _hasForce : Boolean;		/**		 * ForceSprite Constructor		 * @param vx 			the starting <b>velocity</b> (<i>speed</i>) of the object on the <b>x-axis</b>.		 * @param vy 			the starting <b>velocity</b> (<i>speed</i>) of the object on the <b>y-axis</b>.		 * @param mass 			the <b>mass</b> (<i>density</i>) of the object; this value is clamped between <code>0.1 - 0.9</code> however a safer relational range is <code>0.2 - 0.8</code> (Default: <code>0.5</code>).		 * @param friction 		the <b>friction</b> (<i>resistance</i>) the object experiences when touching a <code>bounds</code> surface (Default: <code>0.8</code>).		 * @param gravityX 		the <code>X</code> <b>gravity</b> (<i>constant horizontal</i>) the object experiences (Default: <code>0</code>).		 * @param gravityY 		the <code>Y</code> <b>gravity</b> (<i>constant vertical force</i>) the object experiences (Default: <code>20</code>). 		 * @param bounds 		the <b>bounds</b> (<i>confines</i>) of movement for the object (Default: <code>Canvas.stage</code>).		 * @param isDraggable 	determines whether the object is <b>draggable</b> or not (Default: <code>true</code>).		 * @param hasForce 		whether <b>force</b> (<i>acceleration, mass, gravity</i>) are currently being applied to the object or not (Default: <code>true</code>).		 */		public function ForceSprite(vx : Number = 0, vy : Number = 0, mass : Number = 0.5, friction : Number = 0.8, gravityY : Number = 20, gravityX : Number = 0, bounds : Rectangle = null, isDraggable : Boolean = true, hasForce : Boolean = true) {			super( );			if(bounds) {				this.bounds = bounds;				// constrain within bounds if the default position has overflow				if (x + width >= boundRight || x <= boundLeft) x = boundLeft;				if (y + height >= boundBottom || y <= boundTop) y = boundTop;			}			_vx = vx;			_vy = vy;			_ax = 0;			_ay = 0;			_friction = friction;			_gravityX = gravityX;			_gravityY = gravityY;			this.mass = mass;			this.hasForce = hasForce;			this.isDraggable = isDraggable;		}		/**		 * Handle a collision		 */		public function collide() : void {			_vy *= -1;			_vx *= -1;		}		/**		 * Handle force logic.		 */		protected function frameHandler(e : Event) : void {				if (!_isDrag) {				// store current position				_cx = x;				_cy = y;								// apply mass to acceleration (decrease speed based on mass).				_ax *= (1 - mass);				_ay *= (1 - mass);							// add the necessary "forces" that moves the object.				_vy += _gravityY;				_vy += _ay;				_vx += _gravityX;				_vx += _ax;							// decrease the speed, so the object won't bounce forever.				//_vy *= _friction;				//_vx *= _friction;							// place object				y += _vy;				x += _vx;									// handle bounds: decrease the speed by applying friction when a surface is touched ...				if (y > boundBottom ) {					// When we hit the bottom, reposition the object to be exactly on the					// bottom edge. Reservse the sign of the speedY so we go to the other direction.					y = boundBottom;					_vy *= _friction;					_vx *= _friction;					_vy *= -1;				} else if (y < boundTop) {					y = 0;					_vy *= _friction;					_vy *= -1;				}				if (x > boundRight) {					x = boundRight;					_vx *= _friction;					_vx *= -1;				} else if (x < boundLeft) {					x = 0;					_vx *= _friction;					_vx *= -1;				}			} else {				//trace( "draggin" );				_dx = x;				_dy = y;				_vx = (_dx - _cx) * (friction / 2);				_vy = (_dy - _cy) * (friction / 2);						}		}		/**		 * @inheritDoc		 */		override protected function press(e : MouseEvent = null) : void {			super.press( e );			_isDrag = true;			this.parent.setChildIndex( this, this.parent.numChildren - 1 );			startDrag( false, new Rectangle( bounds.x, bounds.y, (bounds.width - width), (bounds.height - height) ) );		}		/**		 * @inheritDoc		 */		override protected function release(e : MouseEvent = null) : void {			super.release( e );			stopDrag( );			_isDrag = false;			_ax = (_vx - _ax) * friction;			_ay = (_vy - _ay) * friction;		}		/**		 * @inheritDoc		 */		override protected function releaseOutside(e : Event = null) : void {			release( );		}											/**		 * Rectangle value relative to the coordinates of the Sprite's parent that specify a constraint area for the DraggableSprite.		 * <p>If <code>bounds</code> has not been set the <code>Canvas.stage</code> bounds are automatically implemented instead.</p>		 */		public function get bounds() : Rectangle {			return (_boundRect != null) ? _boundRect : new Rectangle( 0, 0, Canvas.stage.stageWidth, Canvas.stage.stageHeight );		}		/**		 * @private		 */		public function set bounds(r : Rectangle) : void {			_boundRect = r;		}		/**		 * Left bounds (<code>DisplayObject</code> registration <code>0,0</code>).		 */		public function get boundLeft() : Number {			return bounds.x;		}		/**		 * Right bounds (<code>DisplayObject</code> registration <code>0,0</code>).		 */		public function get boundRight() : Number {			return bounds.width - width;		}		/**		 * Top bounds (<code>DisplayObject</code> registration <code>0,0</code>).		 */		public function get boundTop() : Number {			return bounds.y;		}		/**		 * Bottom bounds (<code>DisplayObject</code> registration <code>0, 0</code>).		 */		public function get boundBottom() : Number {			return bounds.height - height;		}		/**		 * <code>Boolean</code> value which determines whether the force (<code>frameHandler</code>) is currently being applied. 		 */		public function get hasForce() : Boolean {			return _hasForce;		}		/*** @private */		public function set hasForce(b : Boolean) : void {			if(b && !_hasForce) {				FramePulse.$.addFrameListener( frameHandler );			} else if(!b && _hasForce) {				FramePulse.$.removeFrameListener( frameHandler );			}			_hasForce = hasForce;		}		/**		 * <code>Boolean</code> value which determines whether the object is able to be dragged/thrown.		 */		public function get isDraggable() : Boolean {			return _isDraggable;		}		/*** @private */		public function set isDraggable(b : Boolean) : void {			_isDraggable = interactiveMode = b;			}				/**		 * X-axis acceleration.		 */		public function get ax() : Number {			return _ax;		}		/*** @private */		public function set ax(n : Number) : void {			_ax = n;		}		/**		 * Y-axis acceleration.		 */		public function get ay() : Number {			return _ay;		}		/*** @private */		public function set ay(n : Number) : void {			_ay = n;		}		/**		 * Frictional force being applied.		 */		public function get friction() : Number {			return _friction;		}		/*** @private */		public function set friction(n : Number) : void {			_friction = n;		}		/**		 * X-axis gravitational force being applied.		 */		public function get gravityY() : Number {			return _gravityY;		}		/*** @private */		public function set gravityY(n : Number) : void {			_gravityY = n;		}		/**		 * X-axis gravitational force being applied.		 */		public function get gravityX() : Number {			return _gravityX;		}		/*** @private */		public function set gravityX(gravityX : Number) : void {			_gravityX = gravityX;		}				/**		 * The general mass of the object (decreases acceleration, increases friction).		 */		public function get mass() : Number {			return _mass;		}		/*** @private */		public function set mass(n : Number) : void {			_mass = MathBase.clamp( n, 0.1, 0.9 );		}	}}