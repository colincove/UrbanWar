/** * sekati.media.FLV * @version 1.5.4 * @author jason m horwitz & steve baughman | sekati.com * Copyright (C) 2008-2009 jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.media {	import sekati.log.Logger;		import sekati.events.FramePulse;	import sekati.events.MediaEvent;	import sekati.validators.FileTypeValidator;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.NetStatusEvent;	import flash.media.SoundTransform;	import flash.media.Video;	import flash.net.NetConnection;	import flash.net.NetStream;			/**	 * FLV provides a common media control object for playing <i>progressive</i> video content. 	 * Acceptable file types are defined in <code>FileTypeValidator.IS_VIDEO</code>.	 * @example <listing version="3.0">	 * 		var flv : FLV = new FLV( );	 * 		flv.load( "path/to/video.flv" );	 * 		flv.play( );	 * </listing>	 * @see sekati.ui.FLVPlayer	 * @see sekati.events.MediaEvent	 */	public class FLV extends EventDispatcher implements IProgressiveMedia {				/**		 * Let the video compressor apply the deblocking filter as needed [<i>default</i>].		 */		public static const DEBLOCK_AUTO : int = 0;				/**		 * Do not use a deblocking filter.		 */		public static const DEBLOCK_NONE : int = 1;				/**		 * Uses the Sorenson deblocking filter.		 */		public static const DEBLOCK_SORENSON : int = 2;				/**		 * For On2 video only, uses the On2 deblocking filter but no deringing filter.		 */		public static const DEBLOCK_ON2 : int = 3;				/**		 * For On2 video only, uses the On2 deblocking and deringing filter.		 */		public static const DEBLOCK_ON2_DERINGER : int = 4;				/**		 * For On2 video only, uses the On2 deblocking and a higher-performance On2 deringing filter.		 */		public static const DEBLOCK_ON2_DERINGER_HIGH : int = 5;							/*** @private */		protected var _ns : NetStream;		/*** @private */		protected var _nc : NetConnection;		/*** @private */		protected var _client : Object;		/*** @private */		protected var _video : Video;		/*** @private */		protected var _url : String;		/*** @private */		protected var _isPaused : Boolean;		/*** @private */		protected var _isStarted : Boolean;		/*** @private */		protected var _isBufferPause : Boolean;		/*** @private */		protected var _bufferTime : Number;		/*** @private */		protected var _duration : Number;		/*** @private */		protected var _lastSeekableTime : Number;		/*** @private */		protected var _metadata : Object;		/**		 * FLV Constructor		 */		public function FLV(width : int = 320, height : int = 240, smoothing : Boolean = false, deblocking : int = DEBLOCK_AUTO) {			super( );			_isPaused = false;			_isStarted = false;			_duration = 1000000000; // fix for buffer bar flakiness			_video = new Video( width, height );			_video.smoothing = smoothing;			_video.deblocking = deblocking;		}		/**		 * Load the video and begin playback.		 * @param url 		of the video to be loaded.		 * @param buffer 	in seconds.		 * @throws 			ArgumentError if <code>url</code> is not video type.		 */		public function load(url : String, buffer : uint = 4) : void {			if(!FileTypeValidator.isVideo( url )) {				throw new ArgumentError( "FLV.load() Argument Error: '" + url + "' is not a valid video file type according to FileTypeValidator.IS_VIDEO." );			}			_url = url;			_nc = new NetConnection( );			_nc.connect( null );			_client = new Object( );			_ns = new NetStream( _nc );			_video.attachNetStream( _ns );						/* The standard NS.bufferTime will fire cuePoints out of order			 * so we will utilize a smart-buffer we build ourselves.			 * @see http://www.restlessthinker.com/blog/?p=44			 * // _ns.bufferTime = buffer; 			 */			_bufferTime = buffer;		 						_ns.client = this;			_ns.addEventListener( NetStatusEvent.NET_STATUS, netStatusHandler, false, 0, true );			_client['onMetaData'] = metaDataHandler;			_client['onCuePoint'] = cuePointHandler;			_ns.client = _client;						//start to load movie, pause and put on first frame to see something			play( );			stop( );			FramePulse.$.addFrameListener( progressHandler );		}		// BASIC CONTROLS				/**		 * Start playback.		 */		public function play() : void {			_isStarted = true;			_ns.play( _url );		}		/**		 * Stop playback.		 */		public function stop() : void {			_ns.pause( );			_isStarted = false;			_isPaused = false;		}		/**		 * Pause playback.		 */		public function pause() : void {			if (!_isPaused && _isStarted) {				_isPaused = true;				_ns.togglePause( );			}		}		/**		 * Resume playback.		 */		public function resume() : void {			if (_isPaused && _isStarted) {				_isPaused = false;				_ns.togglePause( );			}		}		/**		 * Pause/Resume playback toggle.		 */		public function togglePause() : void {			_isPaused ? resume( ) : pause( );		}		/**		 * Seek to a playback time.		 * @param time 		in playback to seek to.		 */		public function seek(time : Number) : void {			_ns.seek( resolveTime( time ) );		}		/**		 * Seek to a playback percent (0 - 1).		 * @param percent 	of playback to seek to.		 */		public function seekToPercent(percent : Number) : void {			seek( _duration * percent );		}		/**		 * Fast-Forward playback.		 * @param seconds 		to step forward.		 */		public function fastForward(seconds : Number = 2) : void {			seek( position + seconds );		}		/**		 * Rewind playback.		 * @param seconds 		to step back.		 */		public function rewind(seconds : Number = 2) : void {			seek( position - seconds );		}		/**		 * Stop playback and cleanup.		 */		public function destroy() : void {			stop( );			FramePulse.$.removeFrameListener( progressHandler );			_ns.removeEventListener( NetStatusEvent.NET_STATUS, netStatusHandler );			_video.clear( );			_ns.close( );			_nc.close( );			_video = null;			_ns = null;			_nc = null;			_client = null;		}		// HELPERS		/**		 * Formats time so that it fits inside the available seek scope.		 */		protected function resolveTime(time : Number) : Number {			var maxTime : Number = (!isNaN( _lastSeekableTime )) ? _lastSeekableTime : _duration;			return Math.max( Math.min( time, maxTime ), 0 );		}		/**		 * Handle buffer externally to <code>ns.bufferTime</code> so we can achieve proper cuePoint timing.		 */		protected function checkBuffer() : void {			// we're outta buffer ...			if(percentLoaded <= percentPlayed) {				// video has finished loading				if(percentLoaded >= 1) return; 				// pause playback				if(!_isBufferPause) {					dispatchEvent( new MediaEvent( MediaEvent.REBUFFER ) );					_isBufferPause = true;				}			} else if(percentLoaded >= percentPlayedWithBuffer) {				// resume playback				if(_isBufferPause) {					_isBufferPause = false;					dispatchEvent( new MediaEvent( MediaEvent.REBUFFER_COMPLETE ) );				}			}		}		// PROGRESS, NETSTREAM & NETCONNECTION EVENT HANDLERS		/**		 * Progress frame loop to keep client progress up to date.			 */		protected function progressHandler(e : Event) : void {			dispatchEvent( new MediaEvent( MediaEvent.PROGRESS, null, percentLoaded, percentPlayed ) );			checkBuffer( );		}		/**		 * NetStatus handler.		 */		protected function netStatusHandler(stats : NetStatusEvent) : void {			//trace( "netstat: " + stats.info['code'] );			switch (stats.info['code']) {				case "NetStream.Buffer.Empty" :					dispatchEvent( new MediaEvent( MediaEvent.BUFFER_EMPTY, "bufferEmpty" ) );					break;				case "NetStream.Buffer.Full" :					dispatchEvent( new MediaEvent( MediaEvent.BUFFER_FULL, "bufferFull" ) );					break;				case "NetStream.Buffer.Flush" :					dispatchEvent( new MediaEvent( MediaEvent.BUFFER_FLUSH, "bufferFlush" ) );					break;				case "NetStream.Play.Start" :					dispatchEvent( new MediaEvent( MediaEvent.START, "start" ) );					break;				case "NetStream.Play.Stop" :					dispatchEvent( new MediaEvent( MediaEvent.COMPLETE, "complete" ) );					break;				case "NetStream.Play.StreamNotFound" :					dispatchEvent( new MediaEvent( MediaEvent.STREAM_NOT_FOUND, "play_streamNotFound" ) );					break;				case "NetStream.Seek.InvalidTime" :					dispatchEvent( new MediaEvent( MediaEvent.SEEK_INVALID_TIME, "seek_InvalidTime" ) );					break;				case "NetStream.Seek.Notify" :					dispatchEvent( new MediaEvent( MediaEvent.SEEK_NOTIFY, "seek_notify" ) );					break;				case "NetStream.Play.FileStructureInvalid" :					dispatchEvent( new MediaEvent( MediaEvent.FILE_STRUCTURE_INVALID, "file_structure_invalid" ) );					break;				case "NetStream.Play.NoSupportedTrackFound" :					dispatchEvent( new MediaEvent( MediaEvent.NO_SUPPORTED_TRACK_FOUND, "no_supported_track_found" ) );					break;														default :					//trace( "Unrecognized NetStatusEvent value: " + stats.info['code'] );					dispatchEvent( new MediaEvent( MediaEvent.UNRECOGNIZED, stats.info['code'] ) );			}					}		/**		 * <code>NetStream</code> cuepoint handler.		 */		protected function cuePointHandler(infoObject : Object) : void { 			dispatchEvent( new MediaEvent( MediaEvent.CUE_POINT, MediaEvent.CUE_POINT, NaN, NaN, null, infoObject ) );			Logger.$.info( this, "cuePointHandler:" );			Logger.$.object( infoObject );		  	/*			for (var propName:String in infoObject) {				if (propName != "parameters") {					trace( propName + " = " + infoObject[propName] );				}		        else {					trace( "parameters =" );					if (infoObject['parameters'] != undefined) {						for (var paramName:String in infoObject['parameters']) {							trace( paramName + ": " + infoObject['parameters'][paramName] );						}					}		            else {						trace( "undefined" );					}				} 			}			 */		}				/**		 * <code>NetStream</code> metadata handler.		 * @example <listing version="3.0">		 * //use the embedded metadata height/width to resize video to correct proportions		 * if( Number( metadata['height'] ) > 0) {		 * 		//resize based on width/height		 * 		var newH:Number = Number(metadata['height']);		 * 		var newW:Number = Number(metadata['width']);		 * 		var prop:Number = newW / _initWidth;		 * 				 * 		_video.height = newH * prop;		 * 		_video.width = newW * prop;		 * 	}		 * </listing>		 */		protected function metaDataHandler(metadata : Object) : void {			_duration = metadata['duration'];			_lastSeekableTime = metadata['lastkeyframetimestamp'];			_metadata = metadata;			dispatchEvent( new MediaEvent( MediaEvent.METADATA, MediaEvent.METADATA, NaN, NaN, metadata ) );						Logger.$.info( this, "metaDataHandler event @ " + _ns.time + " => duration: " + metadata['duration'] + ", lastkeyframetimestamp: " + metadata['lastkeyframetimestamp'] + " metadata:" );			Logger.$.object( metadata );						/*			//depends on which application was used to encode the FLV file			SORENSON - INITIAL META:			creationdate - Mon Jun 12 16:21:12 2006 			framerate - 29.9699859619141			audiocodecid - 2			audiodatarate - 64			videocodecid - 5			canSeekToEnd - false			videodatarate - 600			height - 358			width - 150			duration - 17.65			 */			//find what metadata is available now:			/*			for (var i in metadata) {				trace( i + " - " + metadata[i] );			}			//trace cuepoints			for (var j:String in metadata.cuePoints) {				trace( "CUEPOINTS: " + j + " - " + metadata.cuePoints[j] );				for (var k:String in metadata.cuePoints[j]) {					trace( "  CUEPOINTS: " + k + " - " + metadata.cuePoints[j][k] );				}			}			*/					}			// GETTERS & SETTERS		/**		 * Paused status.		 */		public function get isPaused() : Boolean {			return _isPaused;		}		/**		 * Buffering status.		 */		public function get isBuffering() : Boolean {			return _isBufferPause;		}		/**		 * Playing status.		 */		public function get isPlaying() : Boolean {			return (_isStarted && !_isPaused) ? true : false;		}		/**		 * Stopped status.		 */		public function get isStopped() : Boolean {			return !_isStarted;		}		/**		 * The position of the playhead, in seconds.		 */		public function get position() : Number {			return _ns.time;		}		/**		 * The total playback duration, in seconds.		 */		public function get duration() : Number {				return _duration;		}		/**		 * Amount of play-ahead buffer, in seconds.		 */		public function get bufferLength() : Number {			return _ns.bufferLength;		}		/**		 * The percent played (0 - 1). 		 */		public function get percentPlayed() : Number {			return (position / _duration);		}			/**		 * The percent of the movie that <i>should be</i> currently buffered.		 * @see #checkBuffer()		 */		public function get percentPlayedWithBuffer() : Number {			//trace("position: " + position +" ,bufferTime: " + _bufferTime + ", duration: " + _duration);			return ((position + _bufferTime) / _duration);		}		/**		 * The percent loaded (0 - 1).		 */		public function get percentLoaded() : Number {			return ( _ns.bytesLoaded / _ns.bytesTotal );		}					// AUDIO / VIDEO GETTERS & SETTERS		/**		 * The <code>Video</code> instance to be added to the <code>DisplayList</code>.		 */		public function get video() : Video {			return _video;			}			/**		 * The <code>Netstream</code> instance should clients wish to listen to <code>NetStream</code> 		 * directly rather than the more pragmatic but less granular <code>MediaEvent</code>.		 */		public function get ns() : NetStream {			return _ns;			}		/***		 * The video url.		 */		public function get url() : String {			return _url;									}		/**		 * The <code>Video</code> volume (0 - 1).		 */		public function get volume() : Number {			return _ns.soundTransform.volume;		}		/*** @private */		public function set volume(volume : Number) : void {			var st : SoundTransform = _ns.soundTransform;			st.volume = volume;			_ns.soundTransform = st;		}		/***		 * The <code>Video</code> sound panning (-1 - 1).		 */		public function get pan() : Number {			return _ns.soundTransform.pan;		}		/*** @private */		public function set pan(pan : Number) : void {			var st : SoundTransform = _ns.soundTransform;			st.pan = pan;			_ns.soundTransform = st;			}		/***		 * Whether the <code>Video</code> should be smoothed (interpolated) when it is scaled. For smoothing to work, 		 * the player must be in high-quality mode. The default value is <code>false</code> (no smoothing).		 * 		 * <p>For video playback using <i>Flash Player 9.0.115.0</i> and later versions, set this property to true to take 		 * advantage of mipmapping image optimization.</p>		 */		public function get smoothing() : Boolean {			return _video.smoothing;		}		/*** @private */		public function set smoothing(smoothing : Boolean) : void {			_video.smoothing = smoothing;			}			/***		 * Indicates the type of filter applied to decoded video as part of post-processing. The default value is 0, which lets 		 * the video compressor apply a deblocking filter as needed.		 * 		 * <p>Compression of video can result in undesired artifacts. You can use the deblocking property to set filters that 		 * reduce blocking and, for video compressed using the On2 codec, ringing.</p>		 * 		 * <p><i>Blocking</i> refers to visible imperfections between the boundaries of the blocks that compose each video frame. 		 * Ringing refers to distorted edges around elements within a video image.</p>		 * 		 * <p>Two deblocking filters are available: one in the Sorenson codec and one in the On2 VP6 codec. In addition, a deringing 		 * filter is available when you use the On2 VP6 codec. To set a filter use one of the <code>DEBLOCK</code> constants.		 * 		 * <p>If a value greater than 2 is selected for video when you are using the Sorenson codec, the Sorenson decoder defaults to 2.</p>		 * 		 * <p>Using a deblocking filter has an effect on overall playback performance, and it is usually not necessary for high-bandwidth 		 * video. If a user's system is not powerful enough, the user may experience difficulties playing back video with a deblocking 		 * filter enabled.</p>		 * 		 * @see #DEBLOCK_AUTO		 * @see #DEBLOCK_NONE		 * @see #DEBLOCK_SORENSON		 * @see #DEBLOCK_ON2		 * @see #DEBLOCK_ON2_DERINGER		 * @see #DEBLOCK_ON_DERINGER_HIGH		 */		public function get deblocking() : int {			return _video.deblocking;		}		/*** @private */		public function set deblocking(deblocking : int) : void {			_video.deblocking = deblocking;			}			/***		 * The native integer width that the video file was encoded/exported at.		 * 		 * <p>This property may be used to ensure that the user is seeing the video 		 * at the same size at which it was captured, regardless of the actual size 		 * of the Video object on the Stage.</p>		 */		public function get videoWidth() : int {			return _video.videoWidth;		}			/***		 * The native integer height that the video file was encoded/exported at.		 * 		 * <p>This property may be used to ensure that the user is seeing the video 		 * at the same size at which it was captured, regardless of the actual size 		 * of the Video object on the Stage.</p>		 */		public function get videoHeight() : int {			return _video.videoHeight;		}								}}