/** * sekati.managers.KeyManager * @version 1.3.1 * @author jason m horwitz | sekati.com * Copyright (C) 2008  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.managers {	import sekati.display.StageDisplay;		import sekati.core.App;	import sekati.display.Canvas;	import sekati.log.Logger;	import sekati.utils.ArrayUtil;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.ui.Keyboard;			/**	 * KeyManager provides an interface for the centralized registering and handling of 	 * KeyboardEvents via the direct coupling of Keyboard events to actions. Registered	 * Key or Key-Combo's may be added in a repeatable or non-repeatable fashion.	 * @example <listing version="3.0">	 * import sekati.ui.Keyboard	 * 	 * // create a response relationship between a key and method (non-repeatable):	 * KeyManager.$.addKeyListener( handler, false, Keyboard.UP );	 * 	 * // create a response between a key combo and a method (repeatable):	 * KeyManager.$.addKeyListener( handler, true, Keyboard.CONTROL, Keyboard.LEFT );	 * </listing>	 * 	 * @see sekati.ui.Keyboard	 * @see flash.ui.Keyboard	 * @see http://livedocs.adobe.com/flex/3/langref/flash/ui/Keyboard.html	 */	final public class KeyManager {		/*** @private */		private static var _instance : KeyManager;				/*** @private */		private var isEnabled : Boolean;				/*** @private */		private var keyPress : Array;				/*** @private */		private var keyCombo : Array;		/**		 * KeyManager Singleton Constructor		 * @param $ SingletonEnforcer - internal to the AS file; the param prevents external instantiation without error.		 */		public function KeyManager( $ : SingletonEnforcer = null) {			if (!$) {				throw new ArgumentError( "KeyManager is a Singleton and may only be accessed via its accessor methods: 'getInstance()' or '$'." );				}			Logger.$.status( this, " - Keyboard Management Initializes ..." );			keyPress = new Array( );			keyCombo = new Array( );			isEnabled = true;			Canvas.stage.addEventListener( KeyboardEvent.KEY_DOWN, keyPressHandler );			Canvas.stage.addEventListener( KeyboardEvent.KEY_UP, keyReleaseHandler );			Canvas.stage.addEventListener( Event.DEACTIVATE, clearKeys );		}		/**		 * Singleton Accessor		 * @return KeyManager		 */		public static function getInstance() : KeyManager {			if( _instance == null ) _instance = new KeyManager( new SingletonEnforcer( ) );			return _instance;		}		/**		 * Shorthand singleton accessor getter		 * @return KeyManager		 */		public static function get $() : KeyManager {			return KeyManager.getInstance( );			}		/**		 * Indicates whether the KeyManager is enabled (<code>true</code>) or disabled (<code>false</code>).		 */		public function get enabled() : Boolean {			return isEnabled;		}		/**		 * @private		 */		public function set enabled(b : Boolean) : void {			isEnabled = b;			if(!b) {				clearKeys( );			}		}				// EVENT HANDLERS 				/**		 * Add the key to the <code>keyMap</code>.		 */		protected function keyPressHandler(e : KeyboardEvent = null) : void {			if(!enabled) return;			//Logger.$.info( this, "keyPress " + e.keyCode );			if(keyPress.indexOf( e.keyCode ) == -1) {				keyPress.push( e.keyCode );			}			keyCheck( );		}		/**		 * Remove the key from the <code>keyMap</code>.		 */		protected function keyReleaseHandler(e : KeyboardEvent = null) : void {			if(!enabled) return;			// XXX - This is a work-around to resolve FP10.1 compatibility: http://code.google.com/p/sekati/issues/detail?id=83			if (App.FULLSCREEN_ENABLE && e.keyCode == Keyboard.ESCAPE) {				StageDisplay.$.toggleFullscreen( );				}									//Logger.$.info( this, "keyRelease " + e.keyCode );			if(keyPress.indexOf( e.keyCode ) != -1) {				keyPress.splice( keyPress.indexOf( e.keyCode ), 1 );			}			// re add the listener on non-repeat keys			if (!Canvas.stage.hasEventListener( KeyboardEvent.KEY_DOWN )) {				Canvas.stage.addEventListener( KeyboardEvent.KEY_DOWN, keyPressHandler );				}		}		/**		 * Clear the keyMap.		 */		protected function clearKeys(e : Event = null) : void {			keyPress = new Array( );		}		/**		 * Check the key press to see if it matches our handlers.		 */		protected function keyCheck() : void {			for (var i : int = 0; i < keyCombo.length ; i++) {				if(ArrayUtil.compare( keyCombo[i].keys, keyPress )) {					// prevent repeats of this combo					if(!keyCombo[i].repeat) {						Canvas.stage.removeEventListener( KeyboardEvent.KEY_DOWN, keyPressHandler );					}					keyCombo[i].handler( );				}			}		}		// HELPERS				/**		 * Reset the Key Combo and Map.		 */		public function reset() : void {			clearKeys( );			keyCombo = new Array( );		}		/**		 * Destroy the KeyManager instance.		 */		public function destroy() : void {			Canvas.stage.removeEventListener( KeyboardEvent.KEY_DOWN, keyPressHandler );			Canvas.stage.removeEventListener( KeyboardEvent.KEY_UP, keyReleaseHandler );			Canvas.stage.removeEventListener( Event.DEACTIVATE, clearKeys );			isEnabled = false;			keyPress = null;				keyCombo = null;			_instance = null;					}		/**		 * Returns true or false if the key represented by the		 * keyCode passed is being pressed		 */		public function isDown(keyCode : uint) : Boolean {			return Boolean( keyCode in keyPress );		}				// TRIGGERS		/**		 * Add a key or key combo.		 * @param handler 		the function to be fired upon a complete key match.		 * @param repeat 		if <code>true</code> depressed key handler will fire repeatedly, if <code>false</code> key handler will fire only once per press.		 * @param ...keys 		array of <code>keyCodes</code> (uint's) which will trigger the handler.		 * @example <listing version="3.0">		 * KeyManager.$.addKeyListener( runProgram, false, KeyManager.$.CONTROL, KeyManager.$.ENTER );		 * KeyManager.$.addKeyListener( copyText, true, KeyManager.$.CONTROL, KeyManager.$.C ); 		 * </listing>		 */		public function addKeyListener(handler : Function, repeat : Boolean = false, ...keys : Array) : void {			if(keys.length == 0) {				throw new ArgumentError( "adKeyListener() method was invoked without any KeyCode(s) in the '...keys' argument." );				return;			}			if(ArrayUtil.locatePropValIndex( keyCombo, 'handler', handler ) == -1) {				keyCombo.push( { handler:handler, repeat:repeat, keys:keys.sort( Array.NUMERIC ) } );			} else {				Logger.$.error( this, 'adKeyListener() method was invoked with a handler Function which is already managed by another key or key combination.' );				}		}				/**		 * Remove a key or key combo.		 * @param handler 	the function to be fired upon a complete key match.		 * @example <listing version="3.0">		 * KeyManager.$.removeKeyListener( runProgram );		 * KeyManager.$.removeKeyListener( copyText ); 		 * </listing>		 */		public function removeKeyListener(handler : Function) : void {			var keyObj : Number = ArrayUtil.locatePropValIndex( keyCombo, 'handler', handler );			if(keyObj > -1) {				keyCombo = keyCombo.splice( keyObj, 1 );			} else {				Logger.$.error( this, "removeKeyListener() method invoked with a handler Function not managed by a key or key combination." );				}				}	}}/** * Internal class is accessible only to this AS file and is used  * as a constructor param to enforce proper Singleton behavior. */internal class SingletonEnforcer {}		