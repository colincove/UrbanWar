/** * sekati.utils.TextUtil * @version 1.3.0 * @author jason m horwitz | sekati.com * Copyright (C) 2008  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.utils {	import sekati.core.App;	import sekati.utils.TypeEnforcer;	import sekati.validators.StringValidator;	import flash.display.DisplayObject;	import flash.text.Font;	import flash.text.StyleSheet;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.text.TextFieldType;	import flash.text.TextFormat;			/**	 * Static class wrapping various Text utilities.	 */	public class TextUtil {		/**		 * Clear a <code>TextField</code> text or to all <code>TextField</code>'s texts in a <code>DisplayObject</code>.		 * @param o 		<code>DisplayObject</code> that either <i>is</i> or contains <code>TextField</code>'s.		 */			public static function clearFields(o : DisplayObject) : void {			if(o is TextField) {				var tf : TextField = o as TextField;				tf.text = tf.htmlText = '';			} else if(o is DisplayObject) {				for(var i : String in o) { 					if (o[i] is TextField) {						o[i].text = o[i].htmlText = '';					}				}			}					}		/**		 * Apply the application stylesheet to a <code>TextField</code> or to all <code>TextField</code>'s in a <code>DisplayObject</code>.		 * 		 * <p><b>Warning</b>: Unlike <code>formatFields</code> you must <i>reset</i> your <code>htmlText</code> to have the style applied.</p>		 * @param o 			<code>DisplayObject</code> that either <i>is</i> or contains <code>TextField</code>'s.		 * @param stylesheet 	to apply to the <code>TextField</code>'s (Default: <code>App.css</code>).		 * @see sekati.core.App#css		 */		public static function styleFields(o : DisplayObject, stylesheet : StyleSheet = null) : void {			var css : StyleSheet = (stylesheet) ? stylesheet : App.css;			if(o is TextField) {				var tf : TextField = o as TextField;				tf.styleSheet = css;			} else if(o is DisplayObject) {				for(var i : String in o) { 					if (o[i] is TextField && !o[i].styleSheet) {						o[i].styleSheet = css;					} 				}					}		}		/**		 * Apply a <code>TextFormat</code> to a <code>TextField</code> or to all <code>TextField</code>'s in a <code>DisplayObject</code>.		 * @param o 			<code>DisplayObject</code> that either <i>is</i> or contains <code>TextField</code>'s.		 * @param textFormat 	to apply to the <code>TextField</code>'s.		 */		public static function formatFields(o : DisplayObject, textFormat : TextFormat) : void {			if(o is TextField) {				var tf : TextField = o as TextField;				tf.setTextFormat( textFormat );			} else if(o is DisplayObject) {				for(var i : String in o) { 					if (o[i] is TextField && !o[i].styleSheet) {						o[i].setTextFormat( textFormat );					} 				}					}		}			/**		 * Hide a <code>TextField</code> or <code>TextField</code>'s from display (visible false, alpha 0).		 * @see #reveal		 */		public static function hideFields( ...args ) : void {			for(var i : int = 0; i < args.length ; i++) { 				if (args[i] is TextField) {					args[i].alpha = 0;					args[i].visible = false;				}			}			}		/**		 * Reveal a <code>TextField</code> or <code>TextField</code>'s (visible true, alpha 1)		 * @see #hide		 */		public static function revealFields(...args) : void {			for(var i : int = 0; i < args.length ; i++) { 				if (args[i] is TextField) {					args[i].alpha = 1;					args[i].visible = true;				}			}			}				/**		 * Create a <code>TextField</code> instance and return it.		 */		public static function createField(str : String, x : Number = 0, y : Number = 0, width : Number = 200, height : Number = 20, multiline : Boolean = false, font : String = "Verdana", size : Number = 9, color : uint = 0, autoSize : String = 'left', embedFonts : Boolean = false, selectable : Boolean = false, css : StyleSheet = null) : TextField {			var tf : TextField = new TextField( );			var fmt : TextFormat = new TextFormat( font, size, color );			tf.x = x;			tf.y = y;			tf.width = width;			tf.height = height;			tf.autoSize = autoSize;			tf.embedFonts = embedFonts;			tf.selectable = selectable;			tf.multiline = multiline;			tf.textColor = color;			tf.defaultTextFormat = fmt;			tf.htmlText = str;			tf.styleSheet = css;			return tf;		}		/**		 * Set the text of a <code>TextField</code> while preserving the formatting (leading, kerning, etc).		 * XXX - Warning: htmlText and styles can break the formatting: no known fix as of yet.		 */		public static function setFormattedText(tf : TextField, str : String, autoSize : Boolean = true) : void {			var s : String = (StringValidator.isBlank( str )) ? " " : str;			if(autoSize) {				tf.autoSize = TextFieldAutoSize.LEFT;			}			var textFormat : TextFormat = tf.getTextFormat( );			if(tf.type == TextFieldType.INPUT) {				tf.text = s;				} else {				tf.htmlText = s;			}			tf.setTextFormat( textFormat );		}		/**		 * Apply a <code>StyleSheet</code> to a <code>TextField</code> & set its contents.		 * @param tf 			<code>TextField</code> to display.		 * @param str 			of text to apply.		 * @param stylesheet 	to apply to the <code>TextField</code>'s (Default: <code>App.css</code>).		 * @see sekati.core.App#css		 */		public static function setStyledText(tf : TextField, str : String, stylesheet : StyleSheet = null) : void {			styleFields( tf, stylesheet );			tf.htmlText = str;		}				/**		 * Set the <code>TextField</code>'s width for space characters.		 */		public static function setTextSpaceWidth( tf : TextField, space : Number = 1 ) : void {				var fmt : TextFormat = new TextFormat( );			fmt.letterSpacing = space;						var i : int = 0;			while (tf.text.indexOf( " ", i ) > -1) {				var index : int = tf.text.indexOf( " ", i );				tf.setTextFormat( fmt, index, index + 1 );				i = index + 1;			}		}		/**		 * Set the <code>TextField</code> letter spacing formatting.		 */		public static function setTextLetterSpacing( tf : TextField, spacing : Number = 0  ) : void {			var fmt : TextFormat = tf.getTextFormat( );			fmt.letterSpacing = spacing;					tf.setTextFormat( fmt );		}		/**		 * Set the <code>TextField</code> leading formatting.		 */		public static function setTextLeading( tf : TextField, space : Number = 0  ) : void {			var fmt : TextFormat = tf.getTextFormat( );			fmt.leading = space;			tf.setTextFormat( fmt );		}		/**		 * Set the <code>TextField</code> color formatting.		 */		public static function setTextColor(tf : TextField, color : uint, backgroundColor : Number = NaN, borderColor : Number = NaN) : void {			tf.textColor = color;			if(!isNaN( backgroundColor )) {				tf.background = true;				tf.backgroundColor = backgroundColor;			}			if(!isNaN( borderColor )) {				tf.border = true;				tf.borderColor = borderColor;			}		}		/**		 * Set the <code>TextField</code> font formatting.		 */		public static function setTextFont(tf : TextField, fontName : String, fontSize : Number, isEmbedFont : Boolean = false, isBold : Boolean = false, isItalic : Boolean = false, isUnderline : Boolean = false) : void {			var fmt : TextFormat = tf.getTextFormat( );			fmt.font = fontName;			fmt.size = fontSize;			fmt.italic = isItalic;			fmt.bold = isBold;			fmt.underline = isUnderline;			tf.embedFonts = isEmbedFont;			tf.setTextFormat( fmt );		}		/*		public static function truncateText(tf : TextField, maxWidth : Number = NaN, isEllipsed : Boolean = true) : void {			var ellipse : String = "...";			if (isNaN( maxWidth )) {				maxWidth = tf.width;			}			var tmpField : TextField = new TextField( );			tmpField.type = tf.type;			tmpField.setTextFormat( tf.getTextFormat( ) );			tmpField.htmlText = "W";			// test character width			maxWidth -= tmpField.textWidth;			// padding (note: the longer the string, the more padding is required)			tmpField.htmlText = tf.htmlText;			var textWidth : Number = tmpField.textWidth;			if (textWidth > maxWidth) {				var str : String = tf.htmlText;				while (textWidth > maxWidth) {					str = str.substr( 0, str.length - 1 );					tmpField.htmlText = isEllipsed ? str + ellipse : str;					textWidth = tmpField.textWidth;				}				tf.htmlText = isEllipsed ? str + ellipse : str;			}		}		 */		/**		 * Truncate a single-line TextField to a specific width.		 * @param tf 			the textfield to truncate.		 * @param maxWidth 		the desired text width to truncate at.		 * @param isEllipsed 	denotes whether to truncate with the ellipse char "...".		 * @param isLineEllipse gives the option to "ellipse" the entire width of the field.		 */		public static function truncateText(tf : TextField, maxWidth : Number, isEllipsed : Boolean = true, isLineEllipse : Boolean = false) : void {				var ellipse : String = '...';						// save the autosize settings for renewal at the end ...			var autoSizeSetting : String = tf.autoSize;			tf.autoSize = TextFieldAutoSize.NONE;						// subtract a touch of length from the max width to insure no visual overflow ...			//maxWidth = (!isLongEllipse) ? (maxWidth - 5) : (maxWidth -= 10);			// don't ellipse if we fit under the max width.			if (tf.textWidth <= maxWidth && !isLineEllipse) {				return;			}						// hide the field momentarily so the user doesnt see our tests ...			//tf.visible = false;			// save the original text string & it's length			var str : String = tf.htmlText;			var strLength : Number = str.length;						// save the (stereotypical fonts) widest character's width: "W"			tf.htmlText = "W";			var wCharWidth : Number = tf.textWidth;						// save the (stereotypical fonts) medium character's width: "A"			tf.text = "A";			var aCharWidth : Number = tf.textWidth;						// the max num of (the largest) chars which our max desired width can hold. 			var ptr : Number = Math.floor( maxWidth / wCharWidth );						// collect the portion of the string which represents the max large chars (ptr) and add it to the field.			var checkStr : String = str.substr( 0, ptr );			tf.text = checkStr;						// Now that we have a baseline set below our maxWidth we can start adding/testing characters:			// in this way we optimize the number of loops which must be performed which *greatly* improves 			// performance rather than adding/testing thru the entire string (this is especially important			// when using the method on many long texted TextFields: smart, huh?			var cnt : Number;			while (tf.textWidth < maxWidth) {				// see if we can fit one or more standard characters in the space remaining: if we cant: bail.				cnt = Math.floor( (maxWidth - tf.textWidth) / aCharWidth );				if (cnt == 0) {					break;				}				// increase the max chars: if we accidentally went above the str length: fix er up ... 				ptr += cnt;				ptr = (ptr > strLength) ? strLength : ptr;								// once again set a slice of our max fitting chars to the field.				checkStr = str.substr( 0, ptr );				tf.htmlText = checkStr;								// if our max fitting chars is the same as the string length: bail too.				if (strLength == ptr) {					break;				}			}						// if we want to ellipse apply it to the field.			if(isEllipsed) {				tf.appendText( ellipse );			}						// again check if we've exceeded the max desired width ...			if (tf.textWidth > maxWidth) {				// if we have remove a character and test again.				while (tf.textWidth > maxWidth) {					checkStr = checkStr.substr( 0, -1 );					tf.htmlText = isEllipsed ? (checkStr + ellipse) : checkStr;				}			}						// alright - things fit perfectly now! However; maybe you want it to			// "ellipse" thru the entire length of the field for visual effect?			// 			// TODO - Warning: this functions but is not perfect: can be optimized and made more accurate. 			//			if (isLineEllipse) {								var tmpField : TextField = new TextField( );				tmpField.width = tf.width;				tmpField.setTextFormat( tf.getTextFormat( ) );								// save the (stereotypical fonts) smallest character's width: "."				tmpField.htmlText = ".";				var periodCharWidth : Number = tmpField.textWidth;								tmpField.htmlText = "";				var whiteSpaceWidth : Number = tmpField.width - tf.textWidth;				var i : Number = Math.floor( whiteSpaceWidth / periodCharWidth );				while (i-- > 0) {					tmpField.appendText( "." );				}				if (whiteSpaceWidth < tmpField.textWidth) {					while (whiteSpaceWidth < tmpField.textWidth) {						tmpField.htmlText = tmpField.text.substr( 0, -1 );					}				} else if (whiteSpaceWidth > tmpField.textWidth) {					while (tmpField.textWidth < whiteSpaceWidth) {						tmpField.appendText( "." );					}					tmpField.htmlText = tmpField.text.substr( 0, -1 );				}				tf.appendText( tmpField.text );			}						// restore the settings and make the text visible again...			tf.autoSize = autoSizeSetting;			//tf.visible = true;						// defer rendering if the field is on stage to avoid the flickering of the char tests...			//if(tf.stage != null) tf.stage.invalidate( );		}				/**		 * Truncate a multiline <code>TextField</code> after the defined number of lines of text.		 * @param tf 				<code>TextField</code> to truncate.		 * @param numAlllowedLines 	before the remaining text is removed.		 * @param isEllipsed 		determines whether the text is ended with "..." or not.		 */		public static function truncateMultilineText(tf : TextField, numAlllowedLines : uint, isEllipsed : Boolean = true) : void {			if (tf.bottomScrollV > numAlllowedLines) {				var len : int = tf.text.length;				for (var i : int = 0; i < len ; i++) {					tf.scrollV = tf.maxScrollV;					if (tf.bottomScrollV > numAlllowedLines) {						tf.text = tf.text.slice( 0, -1 );					} else {						var e : int = (isEllipsed) ? -3 : tf.text.lastIndexOf( " " );						tf.text = tf.text.slice( 0, e );						tf.appendText( "..." );						break;					}				}			}		}				/**		 * Searches the client's available fonts to see if any of the Font from the <code>desiredFontList</code> are available.		 * @param desiredFontList 	array of desired <code>fontName</code>'s.		 * @return 					array of desired fonts which are available for use on the client's system.		 */		public static function getUsableFonts(desiredFontList : Array) : Array {			var clientFontList : Array = Font.enumerateFonts( true );			var availableFontList : Array = new Array( );			for (var i : Number = 0; i < desiredFontList.length ; i++) {				for (var j : Number = 0; j < clientFontList.length ; j++) {					if (desiredFontList[i] == Font( clientFontList[j] ).fontName) {						availableFontList.push( desiredFontList[i] );					}				}			}			return (availableFontList.length >= 1) ? availableFontList : null;		}				/**		 * TextUtil Static Constructor		 */		public function TextUtil() {			TypeEnforcer.enforceStatic( TextUtil );		}	}}