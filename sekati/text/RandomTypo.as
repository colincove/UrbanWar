/** * sekati.text.RandomTypo * @version 1.0.2 * @author jason m horwitz | sekati.com * Copyright (C) 2009  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.text {	import sekati.events.FramePulse;	import flash.events.Event;	import flash.text.TextField;			/**	 * RandomTypo	 */	public class RandomTypo {		//var listener : Array = [];		//private var typoText : String;				private var randomList : Array = [];		private var cMin : Number = 97; //lower: 97 //upper: 65; //special-all: 33;		private var cMax : Number = 122; //lower: 122 upper: 90; //special-all: 96;		private var moveFix : Number = 7;		private var moveRange : Number = 10;		private var moveTrigger : Number = 12;		private var charSpeed : Number = 2;		private var waitChar : String;		private var description : String;		private var textCount : uint = 0;		private var fixLength : uint = 0;		private var fixStr : String = '';		private var previous_instance : TextField;		private var end_charMotion : Boolean;		private var end_textCount : Boolean;		/**		 * RandomTypo Constructor		 * @example <listing version="3.0">		 * var typo : RandomTypo = new RandomTypo();		 * typo.setText(tf, "Hello World: how are you doing today?");		 * </listing>		 */		public function RandomTypo() {		}		/**		 * Animate the shuffled text		 * @param instance the textfield to animate text in		 * @param str the string to use		 * @param wChar the seperator character to use		 * @param toUpperCase whether to uppercase all final text or not		 * @param mixLower whether to use only lowercase chars in the shuffle (default)		 * @param mixUpper whether to use only lowercase chars in the shuffle		 * @param mixUpperSpecial whether to use uppercase and special chars in the shuffle (overrides other mix args)		 */		public function setText(instance : TextField, str : String, wChar : String = '-', toUpperCase : Boolean = false,  mixLower : Boolean = true, mixUpper : Boolean = false, mixUpperSpecial : Boolean = false, cSpeed : uint = 2, mFix : uint = 10, mRange : uint = 15, mTrigger : uint = 12) : void {			waitChar = wChar;			charSpeed = cSpeed;			moveFix = mFix;			moveRange = mRange;			moveTrigger = mTrigger;			description = (toUpperCase) ? str.toUpperCase( ) : str;			// figure out which charset to use			if(mixUpperSpecial) {				cMin = 33;				cMax = 96;			} else if(mixUpper) {				cMin = 65;				cMax = 90;							} else if(mixLower) {				cMin = 97;				cMax = 122;								}						//			randomList = [];			//listener = [];			var counter : Number = 0;			while (counter <= str.length - 1) {				var char : String = description.charAt( counter );				if (char != ' ') {					randomList[counter] = (moveFix + Math.round( Math.random( ) * moveRange )) * (Math.round( Math.random( ) ) - 0.5) * 2;				} else {					randomList[counter] = 0;				}				counter++;			}			previous_instance = instance;			FramePulse.$.addFrameListener( randomMotion );			/*			counter = 0;			while (counter <= listener.length) {				//listener[counter].onTypoStart( );				counter++;			}			 */				}		private function randomMotion(e : Event = null) : void {			var typoText : String = fixStr;			end_charMotion = true;			var counter : Number = fixLength;			while (counter <= textCount) {				if (randomList[counter] != 0 && randomList[counter] != undefined) {					end_charMotion = false;					var rNum : Number = randomList[counter];					if (Math.abs( rNum ) <= moveTrigger) {						var charcode : Number = Math.min( Math.max( description.charCodeAt( counter ) + rNum, cMin ), cMax );						typoText += String.fromCharCode( charcode );					} else {						typoText += waitChar;					}					if (rNum > 0) {						randomList[counter] -= 1;					} else {						randomList[counter] += 1;					}				} else {					if (fixLength == counter - 1) {						fixLength = counter;						fixStr = description.substring( 0, fixLength );					}					typoText += description.charAt( counter );				}				counter++;			}			if (textCount <= description.length) {				textCount += charSpeed;			} else {				end_textCount = true;			}			if (end_charMotion && end_textCount) {				stopAction( );			}			//trace( typoText );			previous_instance.text = typoText;		}		private function stopAction() : void {			/*			var counter : Number = 0;			while (counter < listener.length) {			//listener[counter].onTypoEnd( );			counter++;			}			 */			FramePulse.$.removeFrameListener( randomMotion );			randomList = [];			textCount = 0;			end_textCount = false;			end_charMotion = false;			fixStr = '';			fixLength = 0;			description = '';					}				/*		private function  clear() : void {			FramePulse.$.removeFrameListener( randomMotion );			typoText = '';			previous_instance = null;		}		private function  addListener(obj : *) : void {			listener.push( obj );		}		 */				}}