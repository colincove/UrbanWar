/** * sekati.crypt.XOR * @version 1.0.1 * @author jason m horwitz | sekati.com * Copyright (C) 2008 jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.crypt {	import sekati.crypt.ICipher;	import sekati.utils.TypeEnforcer;			/**	 * Encrypt and Decrypt a string with XORCRYPT Version 1.2 algorithm	 * @see http://www.eng.uwaterloo.ca/~ejones/software/xorcrypt12.js	 */	final public class XOR implements ICipher {				/**		 * The encryption table:<ul>		 * <li>The last char in the table is always the escape code.</li>		 * <li>The table is not quite 128 chars, it is 95 (minus the escape char).</li>		 * <li>Values 93-127 must be escaped.</li><ul>		 */		private static const CRYPT_TABLE : String = " ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789	!@#$%^&*()`'-=[];,./?_+{}|:<>~";				/**		 * 93 Chars		 */		private static var CRYPT_LENGTH : Number = CRYPT_TABLE.length - 1;			/**		 * The escape code is ~		 * @example <listing version="3.0">private var escapeChar:String = cryptTable.charAt(cryptLength);</listing>		 * The linefeed char - escaped to double escapeChar		 */		private static const LINE_FEED : String = "\n";				/**		 * Double quotes are escaped to ~'		 */		private static const DOUBLE_QUOTE : String = '"';		/**		 * Encrypts a string with the specified key (linefeeds are stripped but replaced upon decryption).		 * @param input string to encrypt		 * @param password encryption key		 * @example <listing version="3.0">		 * var enc:String = XOR.encrypt ("hello world","tooManySecrets");		 * </listing>		 */	 		public static function encrypt(input : String, password : String) : String {			var escapeChar : String = CRYPT_TABLE.charAt( CRYPT_LENGTH );			var inChar : String, inValue : *, outValue : *;			var output : String = "";			var arNumberPw : Array = new Array( );			var pwLength : Number = password.length;			var inLength : Number = input.length;			var pwIndex : Number;			//			for (pwIndex = 0; pwIndex < pwLength ; pwIndex++) {				arNumberPw[pwIndex] = CRYPT_TABLE.indexOf( password.charAt( pwIndex ) );			}			/* XOR all the chars */			pwIndex = 0;			for (var inIndex : Number = 0; inIndex < inLength ; inIndex++, pwIndex++) {				//Make sure the password index is in range					if (pwIndex == pwLength) {					pwIndex = 0;				}				/* Get the input */				inChar = input.charAt( inIndex );				inValue = CRYPT_TABLE.indexOf( inChar );				/* Conversion/Escaping Sequence */				// If the outValue is in the character map, encode it				// If the encoded value is outside the character map, escape it				// Else convert it to a char				// If the input char is a linefeed, escape it				// If the input char is a double quote, escape it				// If the input char wasn't found, pass it through				if (inValue != -1) {					outValue = arNumberPw[pwIndex] ^ inValue;					if (outValue >= CRYPT_LENGTH) {						outValue = escapeChar + CRYPT_TABLE.charAt( Number( outValue ) - CRYPT_LENGTH );					} else {						outValue = CRYPT_TABLE.charAt( Number( outValue ) );					}				} else if (inChar == "\r") {					outValue = escapeChar + escapeChar;					//If it is a 2 char linefeed skip next one					if (input.charAt( inIndex + 1 ) == "\n") {						inIndex++;					}				} else if (inChar == "\n") {					outValue = escapeChar + escapeChar;				} else if (inChar == DOUBLE_QUOTE) {					outValue = escapeChar + "'";				} else {					outValue = inChar;				}				output += String( outValue );			}			return output;		}		/**		 * Decrypts a string with the specified key.		 * @param input string to decrypt		 * @param password decryption key		 * @example <listing version="3.0">		 * var dec:String = XOR.decrypt (enc,"tooManySecrets");		 * </listing>		 */		public static function decrypt(input : String, password : String) : String {			var inChar : String, inValue : *, outValue : *, escape : Boolean = false;			var output : String = "";			var arNumberPw : Array = new Array( );			var pwLength : Number = password.length;			var inLength : Number = input.length;			var pwIndex : Number;			for (pwIndex = 0; pwIndex < pwLength ; pwIndex++) {				arNumberPw[pwIndex] = CRYPT_TABLE.indexOf( password.charAt( pwIndex ) );			}			/* XOR all the chars */			pwIndex = 0;			for (var inIndex : Number = 0; inIndex < inLength ; inIndex++, pwIndex++) {				if (pwIndex >= pwLength) {					//Make sure the password index is in range					pwIndex = 0;				}				/* Get the input */				inChar = input.charAt( inIndex );				inValue = CRYPT_TABLE.indexOf( inChar );				/* Decrypting/Unescaping Sequence */				// If the input char wasn't found, pass it through (error checking)				// If the last char was an escapeChar				//And the input is an escapeChar, output a linefeed				//Or the input is a single quote, output a double quote				//Otherwise just add the cryptLength to the inValue				//Turn escape off				// If the inValue hasn't been coverted to an outValue yet				// If the inChar is an escapeChar, turn escape on				// Otherwise decrypt the encrypted character				if (inValue == -1) {					outValue = inChar;				} else if (escape) {					if (inValue == CRYPT_LENGTH) {						outValue = LINE_FEED;						inValue = -1;					} else if (inChar == "'") {						outValue = DOUBLE_QUOTE;						inValue = -1;					} else {						inValue += CRYPT_LENGTH;					}					escape = false;				} else if (inValue == CRYPT_LENGTH) {					escape = true;					pwIndex--;					//Stop the password from incrementing					outValue = "";					inValue = -1;				}				if (inValue != -1) {					outValue = CRYPT_TABLE.charAt( arNumberPw[pwIndex] ^ inValue );				}				/* Output */				output += String( outValue );			}			return output;		}				/**		 * XOR Static Constructor		 */		public function XOR() {			TypeEnforcer.enforceStatic( XOR );		}	}}