/** * sekati.utils.BitmapTransform * @version 1.0.0 * @author pj ahlberg, jason m horwitz | sekati.com * Copyright (C) 2009  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.utils {	import flash.display.Sprite;		import flash.geom.Matrix;		import flash.geom.Point;		import flash.display.BitmapData;		/**	 * BitmapTransform provides transformation logic for <code>BitmapData</code> transformations.	 * @see sekati.ui.RotationPlane	 */	public class BitmapTransform {		protected var _width : Number;		protected var _height : Number;		protected var _vertsArray : Array;		protected var _newVertsArray : Array;		protected var _hdiv : int;		protected var _vdiv : int;		public var _smooth : Boolean;		/**		 * BitmapTransform Constructor		 * @param width 				of the <code>BitmapData</code>		 * @param height 				of the <code>BitmapData</code>		 * @param horizontalDivisions 	number of horizontal (x) sections to divide the <code>BitmapData</code> transformation with.		 * @param verticalDivisons 		number of vertical (y) sections to divide the <code>BitmapData</code> transformation with.		 * @param smooth 				whether to smooth the <code>BitmapData</code> <code>true<code>, or not <code>false</code>.		 */		public function BitmapTransform(width : Number, height : Number, horizontalDivisions : int = 5, verticalDivisons : int = 5, smooth : Boolean = false) {			_width = width;			_height = height;			_hdiv = horizontalDivisions;			_vdiv = verticalDivisons;			_vertsArray = new Array( );			_newVertsArray = new Array( );			_smooth = smooth;			setVertices( );		}				/**		 * Set the vertices of <code>BitmapData</code>.		 */		protected function setVertices() : void {			var hStep : Number = _width / _hdiv;			var vStep : Number = _height / _vdiv;						for(var j : int = 0; j <= _vdiv ;j++) {				_vertsArray[j] = [];				for(var i : int = 0; i <= _hdiv ;i++) {					_vertsArray[j][i] = new Point( i * hStep, j * vStep );				}			}		}				/**		 * Calculate new vertices for the <code>BitmapData</code>.		 */		protected function calcNewVerts(a : Point,b : Point,c : Point,d : Point) : void {			var verVecLeft : Array = [ d.x - a.x,d.y - a.y ];			var verVecRight : Array = [ c.x - b.x,c.y - b.y ];			var curVert : Point;			var curYCoeff : Number;			var curXCoeff : Number;			var curPointLeft : Point = new Point( );			var curPointRight : Point = new Point( );			var newVert : Point = new Point( );						for(var j : int = 0; j <= _vdiv ;j++) {				_newVertsArray[j] = [];				for(var i : int = 0; i <= _hdiv ;i++) {					_newVertsArray[j][i] = new Point( );					curVert = _vertsArray[j][i];					curYCoeff = curVert.y / _height;					curXCoeff = curVert.x / _width;					curPointLeft.x = a.x + curYCoeff * verVecLeft[0];					curPointLeft.y = a.y + curYCoeff * verVecLeft[1];					curPointRight.x = b.x + curYCoeff * verVecRight[0];					curPointRight.y = b.y + curYCoeff * verVecRight[1];					newVert.x = curPointLeft.x + (curPointRight.x - curPointLeft.x) * curXCoeff;					newVert.y = curPointLeft.y + (curPointRight.y - curPointLeft.y) * curXCoeff;					_newVertsArray[j][i].x = newVert.x;					_newVertsArray[j][i].y = newVert.y;				}			}		}				/**		 * Map the <code>BitmapData</code> transformation.		 */		public function mapBitmapData(bd : BitmapData, topLeft : Point, topRight : Point, bottomRight : Point, bottomLeft : Point, container : Sprite) : void {			var curVertOld0 : Point = new Point( );			var curVertNew0 : Point = new Point( );			var curVertOld1 : Point = new Point( );			var curVertNew1 : Point = new Point( );			var curVertOld2 : Point = new Point( );			var curVertNew2 : Point = new Point( );			var finMat : Matrix = new Matrix( );			var linMat : Matrix = new Matrix( );						calcNewVerts( topLeft, topRight, bottomRight, bottomLeft );						for(var j : int = 0; j < _vdiv ;j++) {				for(var i : int = 0; i < _hdiv ;i++) {					curVertOld0.x = _vertsArray[j][i].x;					curVertOld0.y = _vertsArray[j][i].y;					curVertOld1.x = _vertsArray[j + 1][i].x;					curVertOld1.y = _vertsArray[j + 1][i].y;					curVertOld2.x = _vertsArray[j][i + 1].x;					curVertOld2.y = _vertsArray[j][i + 1].y;					curVertNew0.x = _newVertsArray[j][i].x;					curVertNew0.y = _newVertsArray[j][i].y;					curVertNew1.x = _newVertsArray[j + 1][i].x;					curVertNew1.y = _newVertsArray[j + 1][i].y;					curVertNew2.x = _newVertsArray[j][i + 1].x;					curVertNew2.y = _newVertsArray[j][i + 1].y;									finMat.tx = curVertOld0.x;					finMat.ty = curVertOld0.y;					finMat.a = 0;					finMat.b = (curVertOld1.y - curVertOld0.y) / _width;					finMat.c = (curVertOld2.x - curVertOld0.x) / _height;					finMat.d = 0;					linMat.a = (curVertNew1.x - curVertNew0.x) / _width;					linMat.b = (curVertNew1.y - curVertNew0.y) / _width;					linMat.c = (curVertNew2.x - curVertNew0.x) / _height;					linMat.d = (curVertNew2.y - curVertNew0.y) / _height;					linMat.tx = curVertNew0.x;					linMat.ty = curVertNew0.y;					finMat.invert( );					finMat.concat( linMat );									container.graphics.beginBitmapFill( bd, finMat, false, _smooth );					container.graphics.moveTo( curVertNew0.x, curVertNew0.y );					container.graphics.lineTo( curVertNew1.x, curVertNew1.y );					container.graphics.lineTo( curVertNew2.x, curVertNew2.y );					container.graphics.lineTo( curVertNew0.x, curVertNew0.y );					container.graphics.endFill( );										curVertOld0.x = _vertsArray[j + 1][i + 1].x;					curVertOld0.y = _vertsArray[j + 1][i + 1].y;					curVertOld1.x = _vertsArray[j][i + 1].x;					curVertOld1.y = _vertsArray[j][i + 1].y;					curVertOld2.x = _vertsArray[j + 1][i].x;					curVertOld2.y = _vertsArray[j + 1][i].y;					curVertNew0.x = _newVertsArray[j + 1][i + 1].x;					curVertNew0.y = _newVertsArray[j + 1][i + 1].y;					curVertNew1.x = _newVertsArray[j][i + 1].x;					curVertNew1.y = _newVertsArray[j][i + 1].y;					curVertNew2.x = _newVertsArray[j + 1][i].x;					curVertNew2.y = _newVertsArray[j + 1][i].y;										finMat.tx = curVertOld0.x;					finMat.ty = curVertOld0.y;					finMat.a = 0;					finMat.b = (curVertOld1.y - curVertOld0.y) / _width;					finMat.c = (curVertOld2.x - curVertOld0.x) / _height;					finMat.d = 0;					linMat.a = (curVertNew1.x - curVertNew0.x) / _width;					linMat.b = (curVertNew1.y - curVertNew0.y) / _width;					linMat.c = (curVertNew2.x - curVertNew0.x) / _height;					linMat.d = (curVertNew2.y - curVertNew0.y) / _height;					linMat.tx = curVertNew0.x;					linMat.ty = curVertNew0.y;					finMat.invert( );					finMat.concat( linMat );									container.graphics.beginBitmapFill( bd, finMat, false, _smooth );					container.graphics.moveTo( curVertNew0.x, curVertNew0.y );					container.graphics.lineTo( curVertNew1.x, curVertNew1.y );					container.graphics.lineTo( curVertNew2.x, curVertNew2.y );					container.graphics.lineTo( curVertNew0.x, curVertNew0.y );										container.graphics.endFill( );				}			}			}		}}