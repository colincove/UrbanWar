/** * sekati.profiler.PerformanceMonitorGraph * @version 1.1.1 * @author jason m horwitz | sekati.com * Copyright (C) 2009  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package sekati.profiler {	import flash.events.Event;		import sekati.display.Canvas;	import sekati.display.DraggableSprite;	import sekati.display.LiquidSprite;	import sekati.events.StageEvent;	import sekati.utils.ColorUtil;	import flash.display.CapsStyle;	import flash.display.Graphics;	import flash.display.JointStyle;	import flash.display.LineScaleMode;	import flash.display.Shape;	import flash.geom.Rectangle;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.text.TextFormat;		/**	 * PerformanceMonitorGraph provides the profiler graphing UI.	 */	final internal class PerformanceMonitorGraph extends LiquidSprite {		private static const FPS_GRAPH_COLOR : uint = 0x6666FF;		private static const FPS_GRAPH_ALPHA : Number = 0.25;		private static const RAM_GRAPH_COLOR : uint = 0xFF0099;		private static const RAM_GRAPH_ALPHA : Number = 0.25;		private static const GRAPH_GUIDE_COLOR : uint = 0xFFFFFF;		private static const GRAPH_GUIDE_ALPHA : Number = 0.5; 		private static const GRAPH_GUIDE_ALPHA_DIVISOR : int = 3;		private static const GRAPH_LINE_ALPHA : Number = 0.25;		private static const GRAPH_LINE_THICKNESS : Number = 1;		//		private static const FPS_LABEL : String = ' FPS ';		private static const RAM_LABEL : String = ' MB ';		//		private static const TF_LABEL_COLOR : uint = 0xF7F7F7;		private static const TF_LABEL_STARTX : int = 5;		private static const FPS_LABEL_COLOR : String = ColorUtil.toHTML( FPS_GRAPH_COLOR );		private static const RAM_LABEL_COLOR : String = ColorUtil.toHTML( RAM_GRAPH_COLOR );		//		private static const GRAPH_STARTX : int = 65;		private static const GRAPH_STARTY : int = 35;		private static const GRAPH_HEIGHT : int = 25;		private static const GRAPH_RIGHT_XBUFFER : int = GRAPH_STARTX;		private static const YOFFSET : int = 10;		private static const DECIMAL_PRECISION : int = 3;		//		private static const BG_COLOR : uint = 0x000000;		private static const BG_ALPHA : Number = 0.8;		private static const BG_HEIGHT : int = GRAPH_STARTY + (YOFFSET * 2);		//		private var dragContainer : DraggableSprite;		private var minFpsTf : TextField;		private var maxFpsTf : TextField;		private var minMemTf : TextField;		private var maxMemTf : TextField;		private var infoTf : TextField;		private var bg : Shape;		private var fpsLine : Shape;		private var ramLine : Shape;		/**		 * PerformanceMonitorGraph Constructor		 */		public function PerformanceMonitorGraph() : void {			configUI( );		}		/**		 * Configure UI elements: this occurs outside of the constructor to leverage the JIT compiler.		 */		private function configUI() : void {			dragContainer = new DraggableSprite( new Rectangle( 0, 0, Canvas.stage.stageWidth, Canvas.stage.stageHeight ) );			fpsLine = new Shape( );			ramLine = new Shape( );			bg = new Shape( );						fpsLine.x = ramLine.x = GRAPH_STARTX;			fpsLine.y = ramLine.y = GRAPH_STARTY;							var fmt : TextFormat = new TextFormat( '_sans', 9, TF_LABEL_COLOR, true );						infoTf = new TextField( );			infoTf.autoSize = TextFieldAutoSize.LEFT;			infoTf.defaultTextFormat = fmt;			infoTf.text = "???";			infoTf.y = (BG_HEIGHT - infoTf.height);			//			minFpsTf = new TextField( );			minFpsTf.autoSize = TextFieldAutoSize.LEFT;			minFpsTf.defaultTextFormat = fmt;			minFpsTf.textColor = FPS_GRAPH_COLOR;			minFpsTf.text = "???";			minFpsTf.y = (GRAPH_STARTY - minFpsTf.height + (YOFFSET / 2));			//			maxFpsTf = new TextField( );			maxFpsTf.autoSize = TextFieldAutoSize.LEFT;			maxFpsTf.defaultTextFormat = fmt;			maxFpsTf.textColor = FPS_GRAPH_COLOR;			maxFpsTf.text = "???";			maxFpsTf.y = (GRAPH_STARTY - GRAPH_HEIGHT - (YOFFSET / 3));			//			minMemTf = new TextField( );			minMemTf.autoSize = TextFieldAutoSize.LEFT;			minMemTf.defaultTextFormat = fmt;			minMemTf.textColor = RAM_GRAPH_COLOR;			minMemTf.text = "???";			minMemTf.y = (GRAPH_STARTY - minFpsTf.height + (YOFFSET / 2));			//			maxMemTf = new TextField( );			maxMemTf.autoSize = TextFieldAutoSize.LEFT;			maxMemTf.defaultTextFormat = fmt;			maxMemTf.textColor = RAM_GRAPH_COLOR;			maxMemTf.text = "???";			maxMemTf.y = (GRAPH_STARTY - GRAPH_HEIGHT - (YOFFSET / 3));			//			minFpsTf.x = maxFpsTf.x = TF_LABEL_STARTX;			minMemTf.x = maxMemTf.x = (Canvas.stage.stageWidth - GRAPH_RIGHT_XBUFFER) + 5;						// XXX - As of FlexSDK 4.5.1 calling resize here crashes flashplayer 11 (?!?!). 			//resize( );						dragContainer.addChildren( bg, infoTf, minFpsTf, maxFpsTf, minMemTf, maxMemTf, fpsLine, ramLine );			addChild( dragContainer );		}		/**		 * Update the graph.		 */		public function update() : void {			try {				if(PerformanceMonitor.$.runningTime >= 1) {					minFpsTf.text = PerformanceMonitor.$.minFps.toFixed( DECIMAL_PRECISION ) + FPS_LABEL;					maxFpsTf.text = PerformanceMonitor.$.maxFps.toFixed( DECIMAL_PRECISION ) + FPS_LABEL;					minMemTf.text = PerformanceMonitor.$.minMem.toFixed( DECIMAL_PRECISION ) + RAM_LABEL;					maxMemTf.text = PerformanceMonitor.$.maxMem.toFixed( DECIMAL_PRECISION ) + RAM_LABEL;				}				infoTf.htmlText = "Current FPS <font color='" + FPS_LABEL_COLOR + "'> " + PerformanceMonitor.$.currentFps.toFixed( DECIMAL_PRECISION ) + "</font>   |   Average FPS <font color='" + FPS_LABEL_COLOR + "'> " + PerformanceMonitor.$.averageFps.toFixed( DECIMAL_PRECISION ) + "</font>   |   Current RAM <font color='" + RAM_LABEL_COLOR + "'> " + PerformanceMonitor.$.currentMem.toFixed( DECIMAL_PRECISION ) + RAM_LABEL + "</font>   |   Peak RAM <font color='" + RAM_LABEL_COLOR + "'> " + PerformanceMonitor.$.maxMem.toFixed( DECIMAL_PRECISION ) + RAM_LABEL + "</font>";				infoTf.x = (Canvas.stage.stageWidth - infoTf.width - GRAPH_RIGHT_XBUFFER);								// FPS				var vec : Graphics = fpsLine.graphics;				vec.clear( );				vec.lineStyle( GRAPH_LINE_THICKNESS, FPS_GRAPH_COLOR, GRAPH_LINE_ALPHA, true, LineScaleMode.NORMAL, CapsStyle.ROUND, JointStyle.ROUND, 8 );				vec.beginFill( FPS_GRAPH_COLOR, FPS_GRAPH_ALPHA );							var i : int = 0;				var len : int = PerformanceMonitor.$.fpsList.length;				var width : int = (Canvas.stage.stageWidth - (GRAPH_STARTX + GRAPH_RIGHT_XBUFFER)) - 1;				var inc : Number = (width / (PerformanceMonitor.$.history - 1));				var rateRange : Number = (PerformanceMonitor.$.maxFps - PerformanceMonitor.$.minFps);				var value : Number;				var curX : Number;				var curY : Number;								// draw fps				for(i = 0; i < len ; i++) {					value = ((PerformanceMonitor.$.fpsList[i] - PerformanceMonitor.$.minFps) / rateRange);					curY = (-value * GRAPH_HEIGHT);					if(i == 0) {						vec.moveTo( 0, curY );					} else {						curX = (i * inc);						vec.lineTo( curX, curY );					}				}								// close the shape				vec.lineTo( curX, GRAPH_STARTY - GRAPH_HEIGHT - YOFFSET - 1 );				vec.lineTo( 1, GRAPH_STARTY - GRAPH_HEIGHT - YOFFSET - 1 );				vec.endFill( );								// RAM				vec = ramLine.graphics;				vec.clear( );				vec.lineStyle( GRAPH_LINE_THICKNESS, RAM_GRAPH_COLOR, GRAPH_LINE_ALPHA, true, LineScaleMode.NORMAL, CapsStyle.ROUND, JointStyle.ROUND, 8 );				vec.beginFill( RAM_GRAPH_COLOR, RAM_GRAPH_ALPHA );												i = 0;				len = PerformanceMonitor.$.memList.length;				rateRange = (PerformanceMonitor.$.maxMem - PerformanceMonitor.$.minMem);								// draw ram				for(i = 0; i < len ; i++) {					value = (PerformanceMonitor.$.memList[i] - PerformanceMonitor.$.minMem) / rateRange;					curY = (-value * GRAPH_HEIGHT);					//(i == 0) ? vec.moveTo( 0, (-value * GRAPH_HEIGHT) ) : vec.lineTo( (i * inc), (-value * GRAPH_HEIGHT) );					if(i == 0) {						vec.moveTo( 0, curY );							} else {						curX = (i * inc);						vec.lineTo( curX, curY );					}				}				// close the shape				vec.lineTo( curX, GRAPH_STARTY - GRAPH_HEIGHT - YOFFSET - 1 );				vec.lineTo( 1, GRAPH_STARTY - GRAPH_HEIGHT - YOFFSET - 1 );				vec.endFill( );							} catch(e : Error) {			}		}		/**		 * @inheritDoc		 */				override protected function resize(e : StageEvent = null) : void {			minMemTf.x = maxMemTf.x = (Canvas.stage.stageWidth - GRAPH_RIGHT_XBUFFER) + 5;						var vec : Graphics = bg.graphics;			vec.clear( );						// draw background panel				vec.beginFill( BG_COLOR, BG_ALPHA );			vec.drawRect( 0, 0, Canvas.stage.stageWidth, BG_HEIGHT );			vec.endFill( );			vec.lineStyle( GRAPH_LINE_THICKNESS, GRAPH_GUIDE_COLOR, GRAPH_GUIDE_ALPHA );						var graphWidth : Number = (Canvas.stage.stageWidth - GRAPH_RIGHT_XBUFFER);			//-------------------------------			// FPS GRAPH GUIDE			// Left V-line				vec.moveTo( GRAPH_STARTX, GRAPH_STARTY );			vec.lineTo( GRAPH_STARTX, (GRAPH_STARTY - GRAPH_HEIGHT) );			// Right V-line			vec.moveTo( graphWidth - 1, GRAPH_STARTY );			vec.lineTo( graphWidth - 1, GRAPH_STARTY - GRAPH_HEIGHT );						/*			// 1/2 V-line			vec.moveTo( graphWidth / 2, GRAPH_STARTY );			vec.lineStyle( GRAPH_LINE_THICKNESS, GRAPH_GUIDE_COLOR, GRAPH_GUIDE_ALPHA / GRAPH_GUIDE_ALPHA_DIVISOR );			vec.lineTo( graphWidth / 2, GRAPH_STARTY - GRAPH_HEIGHT );								// 1/4 V-line			vec.moveTo( graphWidth / 4, GRAPH_STARTY );			vec.lineTo( graphWidth / 4, GRAPH_STARTY - GRAPH_HEIGHT );								// 3/4 V-line			vec.moveTo( graphWidth / 4 + graphWidth / 2, GRAPH_STARTY );			vec.lineTo( graphWidth / 4 + graphWidth / 2, GRAPH_STARTY - GRAPH_HEIGHT );												*/			// Bottom H-line			vec.moveTo( GRAPH_STARTX, GRAPH_STARTY );			vec.lineStyle( GRAPH_LINE_THICKNESS, GRAPH_GUIDE_COLOR, GRAPH_GUIDE_ALPHA );			vec.lineTo( graphWidth, GRAPH_STARTY );						// 1/2 H-line			vec.moveTo( GRAPH_STARTX + 1, (GRAPH_STARTY - GRAPH_HEIGHT / 2) );			vec.lineStyle( GRAPH_LINE_THICKNESS, GRAPH_GUIDE_COLOR, GRAPH_GUIDE_ALPHA / GRAPH_GUIDE_ALPHA_DIVISOR );			vec.lineTo( graphWidth - 1, (GRAPH_STARTY - GRAPH_HEIGHT / 2) );									// Top H-line			vec.lineStyle( GRAPH_LINE_THICKNESS, GRAPH_GUIDE_COLOR, GRAPH_GUIDE_ALPHA );			vec.moveTo( GRAPH_STARTX, GRAPH_STARTY - GRAPH_HEIGHT - 1 );			vec.lineTo( graphWidth, GRAPH_STARTY - GRAPH_HEIGHT - 1 );									//-------------------------------			infoTf.x = (Canvas.stage.stageWidth - infoTf.width - GRAPH_RIGHT_XBUFFER);			dragContainer.bounds = new Rectangle( 0, 0, Canvas.stage.stageWidth, Canvas.stage.stageHeight );			update( );		}			/**		 * Resize when added back to the stage to solve fullscreen while offstage issues.		 * 		 * @inheritDoc		 */		override protected function onStage(e : Event = null) : void {			super.onStage( e );			resize( );		}		/**		 * @inheritDoc		 */		override protected function resizeComplete(e : StageEvent = null) : void {			super.resizeComplete( e );			// keep the profiler on stage!			if(dragContainer.y < 0 || dragContainer.y > Canvas.stage.stageHeight) {				dragContainer.y = 0;			}		}	}}